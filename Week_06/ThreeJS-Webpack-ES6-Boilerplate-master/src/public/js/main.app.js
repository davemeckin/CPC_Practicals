(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./src/css/app.scss":
/*!**************************!*\
  !*** ./src/css/app.scss ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/css/app.scss?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data/config */ \"./src/js/data/config.js\");\n/* harmony import */ var _utils_detector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/detector */ \"./src/js/utils/detector.js\");\n/* harmony import */ var _app_main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app/main */ \"./src/js/app/main.js\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../css/app.scss */ \"./src/css/app.scss\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_css_app_scss__WEBPACK_IMPORTED_MODULE_3__);\n\n\n // Styles\n\n // Check environment and set the Config helper\n\nif (true) {\n  console.log('----- RUNNING IN DEV ENVIRONMENT! -----');\n  _data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isDev = true;\n}\n\nfunction init() {\n  // Check for webGL capabilities\n  if (!_utils_detector__WEBPACK_IMPORTED_MODULE_1__[\"default\"].webgl) {\n    _utils_detector__WEBPACK_IMPORTED_MODULE_1__[\"default\"].addGetWebGLMessage();\n  } else {\n    var container = document.getElementById('appContainer');\n    new _app_main__WEBPACK_IMPORTED_MODULE_2__[\"default\"](container);\n  }\n}\n\ninit();\n\n//# sourceURL=webpack:///./src/js/app.js?");

/***/ }),

/***/ "./src/js/app/components/camera.js":
/*!*****************************************!*\
  !*** ./src/js/app/components/camera.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Camera; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Class that creates and updates the main camera\n\nvar Camera = /*#__PURE__*/function () {\n  function Camera(renderer) {\n    var _this = this;\n\n    _classCallCheck(this, Camera);\n\n    var width = renderer.domElement.width;\n    var height = renderer.domElement.height; // Create and position a Perspective Camera\n\n    this.threeCamera = new three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.fov, width / height, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.near, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.far);\n    this.threeCamera.position.set(_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.posX, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.posY, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].camera.posZ); // Initial sizing\n\n    this.updateSize(renderer); // Listeners\n\n    window.addEventListener('resize', function () {\n      return _this.updateSize(renderer);\n    }, false);\n  }\n\n  _createClass(Camera, [{\n    key: \"updateSize\",\n    value: function updateSize(renderer) {\n      // Update camera aspect ratio with window aspect ratio\n      this.threeCamera.aspect = renderer.domElement.width / renderer.domElement.height; // Always call updateProjectionMatrix on camera change\n\n      this.threeCamera.updateProjectionMatrix();\n    }\n  }]);\n\n  return Camera;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/camera.js?");

/***/ }),

/***/ "./src/js/app/components/controls.js":
/*!*******************************************!*\
  !*** ./src/js/app/components/controls.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Controls; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/orbitControls */ \"./src/js/utils/orbitControls.js\");\n/* harmony import */ var _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_orbitControls__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // Controls based on orbit controls\n\nvar Controls = /*#__PURE__*/function () {\n  function Controls(camera, container) {\n    _classCallCheck(this, Controls);\n\n    // Orbit controls first needs to pass in THREE to constructor\n    var orbitControls = new _utils_orbitControls__WEBPACK_IMPORTED_MODULE_1___default.a(three__WEBPACK_IMPORTED_MODULE_0__);\n    this.threeControls = new orbitControls(camera, container);\n    this.init();\n  }\n\n  _createClass(Controls, [{\n    key: \"init\",\n    value: function init() {\n      this.threeControls.target.set(_data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.x, _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.y, _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.target.z);\n      this.threeControls.autoRotate = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.autoRotate;\n      this.threeControls.autoRotateSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.autoRotateSpeed;\n      this.threeControls.rotateSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.rotateSpeed;\n      this.threeControls.zoomSpeed = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.zoomSpeed;\n      this.threeControls.minDistance = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.minDistance;\n      this.threeControls.maxDistance = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.maxDistance;\n      this.threeControls.minPolarAngle = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.minPolarAngle;\n      this.threeControls.maxPolarAngle = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.maxPolarAngle;\n      this.threeControls.enableDamping = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.enableDamping;\n      this.threeControls.enableZoom = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.enableZoom;\n      this.threeControls.dampingFactor = _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].controls.dampingFactor;\n    }\n  }]);\n\n  return Controls;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/controls.js?");

/***/ }),

/***/ "./src/js/app/components/geometry.js":
/*!*******************************************!*\
  !*** ./src/js/app/components/geometry.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Geometry; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./material */ \"./src/js/app/components/material.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // This helper class can be used to create and then place geometry in the scene\n\nvar Geometry = /*#__PURE__*/function () {\n  function Geometry(scene) {\n    _classCallCheck(this, Geometry);\n\n    this.scene = scene;\n    this.geo = null;\n  }\n\n  _createClass(Geometry, [{\n    key: \"make\",\n    value: function make(type) {\n      var _this = this;\n\n      if (type === 'plane') {\n        return function (width, height) {\n          var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n          var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n          _this.geo = new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneGeometry\"](width, height, widthSegments, heightSegments);\n        };\n      }\n\n      if (type === 'sphere') {\n        return function (radius) {\n          var widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n          var heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n          _this.geo = new three__WEBPACK_IMPORTED_MODULE_0__[\"SphereGeometry\"](radius, widthSegments, heightSegments);\n        };\n      }\n    }\n  }, {\n    key: \"place\",\n    value: function place(position, rotation) {\n      var _mesh$position, _mesh$rotation;\n\n      var material = new _material__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0xeeeeee).standard;\n      var mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](this.geo, material); // Use ES6 spread to set position and rotation from passed in array\n\n      (_mesh$position = mesh.position).set.apply(_mesh$position, _toConsumableArray(position));\n\n      (_mesh$rotation = mesh.rotation).set.apply(_mesh$rotation, _toConsumableArray(rotation));\n\n      if (_data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].shadow.enabled) {\n        mesh.receiveShadow = true;\n      }\n\n      this.scene.add(mesh);\n    }\n  }]);\n\n  return Geometry;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/geometry.js?");

/***/ }),

/***/ "./src/js/app/components/light.js":
/*!****************************************!*\
  !*** ./src/js/app/components/light.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Light; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Sets up and places all lights in scene\n\nvar Light = /*#__PURE__*/function () {\n  function Light(scene) {\n    _classCallCheck(this, Light);\n\n    this.scene = scene;\n    this.init();\n  }\n\n  _createClass(Light, [{\n    key: \"init\",\n    value: function init() {\n      // Ambient\n      this.ambientLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"AmbientLight\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ambientLight.color);\n      this.ambientLight.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ambientLight.enabled; // Point light\n\n      this.pointLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"PointLight\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.color, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.intensity, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.distance);\n      this.pointLight.position.set(_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.x, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.y, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.z);\n      this.pointLight.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].pointLight.enabled; // Directional light\n\n      this.directionalLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"DirectionalLight\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.color, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.intensity);\n      this.directionalLight.position.set(_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.x, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.y, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.z);\n      this.directionalLight.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].directionalLight.enabled; // Shadow map\n\n      this.directionalLight.castShadow = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.enabled;\n      this.directionalLight.shadow.bias = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.bias;\n      this.directionalLight.shadow.camera.near = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.near;\n      this.directionalLight.shadow.camera.far = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.far;\n      this.directionalLight.shadow.camera.left = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.left;\n      this.directionalLight.shadow.camera.right = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.right;\n      this.directionalLight.shadow.camera.top = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.top;\n      this.directionalLight.shadow.camera.bottom = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.bottom;\n      this.directionalLight.shadow.mapSize.width = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.mapWidth;\n      this.directionalLight.shadow.mapSize.height = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.mapHeight; // Shadow camera helper\n\n      this.directionalLightHelper = new three__WEBPACK_IMPORTED_MODULE_0__[\"CameraHelper\"](this.directionalLight.shadow.camera);\n      this.directionalLightHelper.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shadow.helperEnabled; // Hemisphere light\n\n      this.hemiLight = new three__WEBPACK_IMPORTED_MODULE_0__[\"HemisphereLight\"](_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.color, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.groundColor, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.intensity);\n      this.hemiLight.position.set(_data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.x, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.y, _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.z);\n      this.hemiLight.visible = _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hemiLight.enabled;\n    }\n  }, {\n    key: \"place\",\n    value: function place(lightName) {\n      switch (lightName) {\n        case 'ambient':\n          this.scene.add(this.ambientLight);\n          break;\n\n        case 'directional':\n          this.scene.add(this.directionalLight);\n          this.scene.add(this.directionalLightHelper);\n          break;\n\n        case 'point':\n          this.scene.add(this.pointLight);\n          break;\n\n        case 'hemi':\n          this.scene.add(this.hemiLight);\n          break;\n      }\n    }\n  }]);\n\n  return Light;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/light.js?");

/***/ }),

/***/ "./src/js/app/components/material.js":
/*!*******************************************!*\
  !*** ./src/js/app/components/material.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Material; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n // USe this class as a helper to set up some default materials\n\nvar Material = function Material(color) {\n  _classCallCheck(this, Material);\n\n  this.basic = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\n    color: color,\n    side: three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"]\n  });\n  this.standard = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"]({\n    color: color,\n    shading: three__WEBPACK_IMPORTED_MODULE_0__[\"FlatShading\"],\n    roughness: 1,\n    metalness: 0,\n    side: three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"]\n  });\n  this.wire = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\n    wireframe: true\n  });\n};\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/material.js?");

/***/ }),

/***/ "./src/js/app/components/renderer.js":
/*!*******************************************!*\
  !*** ./src/js/app/components/renderer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Renderer; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Main webGL renderer class\n\nvar Renderer = /*#__PURE__*/function () {\n  function Renderer(scene, container) {\n    var _this = this;\n\n    _classCallCheck(this, Renderer);\n\n    // Properties\n    this.scene = scene;\n    this.container = container; // Create WebGL renderer and set its antialias\n\n    this.threeRenderer = new three__WEBPACK_IMPORTED_MODULE_0__[\"WebGLRenderer\"]({\n      antialias: true\n    }); // Set clear color to fog to enable fog or to hex color for no fog\n\n    this.threeRenderer.setClearColor(scene.fog.color);\n    this.threeRenderer.setPixelRatio(window.devicePixelRatio); // For retina\n    // Appends canvas\n\n    container.appendChild(this.threeRenderer.domElement); // Shadow map options\n\n    this.threeRenderer.shadowMap.enabled = true;\n    this.threeRenderer.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_0__[\"PCFSoftShadowMap\"]; // Get anisotropy for textures\n\n    _data_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].maxAnisotropy = this.threeRenderer.capabilities.getMaxAnisotropy(); // Initial size update set to canvas container\n\n    this.updateSize(); // Listeners\n\n    document.addEventListener('DOMContentLoaded', function () {\n      return _this.updateSize();\n    }, false);\n    window.addEventListener('resize', function () {\n      return _this.updateSize();\n    }, false);\n  }\n\n  _createClass(Renderer, [{\n    key: \"updateSize\",\n    value: function updateSize() {\n      this.threeRenderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n    }\n  }, {\n    key: \"render\",\n    value: function render(scene, camera) {\n      // Renders scene to canvas target\n      this.threeRenderer.render(scene, camera);\n    }\n  }]);\n\n  return Renderer;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/components/renderer.js?");

/***/ }),

/***/ "./src/js/app/helpers/meshHelper.js":
/*!******************************************!*\
  !*** ./src/js/app/helpers/meshHelper.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MeshHelper; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _vertexNormalsHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vertexNormalsHelper */ \"./src/js/app/helpers/vertexNormalsHelper.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Simple mesh helper that shows edges, wireframes, and face and vertex normals\n\nvar MeshHelper = /*#__PURE__*/function () {\n  function MeshHelper(scene, mesh) {\n    _classCallCheck(this, MeshHelper);\n\n    this.mesh = mesh;\n    this.scene = scene;\n    var wireframe = new three__WEBPACK_IMPORTED_MODULE_0__[\"WireframeGeometry\"](this.mesh.geometry);\n    this.wireLine = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineSegments\"](wireframe);\n    this.wireLine.material.depthTest = false;\n    this.wireLine.material.opacity = 0.25;\n    this.wireLine.material.transparent = true;\n    var edges = new three__WEBPACK_IMPORTED_MODULE_0__[\"EdgesGeometry\"](this.mesh.geometry);\n    this.edgesLine = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineSegments\"](edges);\n    this.edgesLine.material.depthTest = false;\n    this.edgesLine.material.opacity = 0.25;\n    this.edgesLine.material.transparent = true;\n    this.vertexHelper = new _vertexNormalsHelper__WEBPACK_IMPORTED_MODULE_1__[\"VertexNormalsHelper\"](this.mesh, 2);\n    this.boxHelper = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxHelper\"](this.mesh);\n  }\n\n  _createClass(MeshHelper, [{\n    key: \"enable\",\n    value: function enable() {\n      this.mesh.add(this.wireLine);\n      this.mesh.add(this.edgesLine);\n      this.scene.add(this.vertexHelper);\n      this.scene.add(this.boxHelper);\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.mesh.remove(this.wireLine);\n      this.mesh.remove(this.edgesLine);\n      this.scene.remove(this.vertexHelper);\n      this.scene.remove(this.boxHelper);\n    }\n  }]);\n\n  return MeshHelper;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/helpers/meshHelper.js?");

/***/ }),

/***/ "./src/js/app/helpers/stats.js":
/*!*************************************!*\
  !*** ./src/js/app/helpers/stats.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Stats; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Local vars for rStats\nvar rS, bS, glS, tS;\n\nvar Stats = /*#__PURE__*/function () {\n  function Stats(renderer) {\n    _classCallCheck(this, Stats);\n\n    this.renderer = renderer;\n  }\n\n  _createClass(Stats, [{\n    key: \"setUp\",\n    value: function setUp() {\n      bS = new BrowserStats();\n      glS = new glStats();\n      tS = new threeStats(this.renderer.threeRenderer);\n      rS = new rStats({\n        CSSPath: './css/',\n        userTimingAPI: true,\n        values: {\n          frame: {\n            caption: 'Total frame time (ms)',\n            over: 16,\n            average: true,\n            avgMs: 100\n          },\n          fps: {\n            caption: 'Framerate (FPS)',\n            below: 30\n          },\n          calls: {\n            caption: 'Calls (three.js)',\n            over: 3000\n          },\n          raf: {\n            caption: 'Time since last rAF (ms)',\n            average: true,\n            avgMs: 100\n          },\n          rstats: {\n            caption: 'rStats update (ms)',\n            average: true,\n            avgMs: 100\n          },\n          texture: {\n            caption: 'GenTex',\n            average: true,\n            avgMs: 100\n          }\n        },\n        groups: [{\n          caption: 'Framerate',\n          values: ['fps', 'raf']\n        }, {\n          caption: 'Frame Budget',\n          values: ['frame', 'texture', 'setup', 'render']\n        }],\n        fractions: [{\n          base: 'frame',\n          steps: ['texture', 'setup', 'render']\n        }],\n        plugins: [bS, tS]\n      });\n    }\n  }], [{\n    key: \"start\",\n    value: function start() {\n      rS('frame').start();\n      glS.start();\n      rS('rAF').tick();\n      rS('FPS').frame();\n      rS('render').start();\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      rS('render').end(); // render finished\n\n      rS('frame').end(); // frame finished\n      // Local rStats update\n\n      rS('rStats').start();\n      rS().update();\n      rS('rStats').end();\n    }\n  }]);\n\n  return Stats;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/helpers/stats.js?");

/***/ }),

/***/ "./src/js/app/helpers/vertexNormalsHelper.js":
/*!***************************************************!*\
  !*** ./src/js/app/helpers/vertexNormalsHelper.js ***!
  \***************************************************/
/*! exports provided: VertexNormalsHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VertexNormalsHelper\", function() { return VertexNormalsHelper; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\n\nvar _v1 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n\nvar _v2 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n\nvar _normalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix3\"]();\n\nvar _keys = ['a', 'b', 'c'];\n\nfunction VertexNormalsHelper(object, size, hex) {\n  this.object = object;\n  this.size = size !== undefined ? size : 0.1;\n  var color = hex !== undefined ? hex : 0xff0000; //\n\n  var nNormals = 0;\n  var objGeometry = this.object.geometry;\n\n  if (objGeometry && objGeometry.isGeometry) {\n    nNormals = objGeometry.faces.length * 3;\n  } else if (objGeometry && objGeometry.isBufferGeometry) {\n    nNormals = objGeometry.attributes.normal.count;\n  } //\n\n\n  var geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"]();\n  var positions = new three__WEBPACK_IMPORTED_MODULE_0__[\"Float32BufferAttribute\"](nNormals * 2 * 3, 3);\n  geometry.setAttribute('position', positions);\n  three__WEBPACK_IMPORTED_MODULE_0__[\"LineSegments\"].call(this, geometry, new three__WEBPACK_IMPORTED_MODULE_0__[\"LineBasicMaterial\"]({\n    color: color,\n    toneMapped: false\n  }));\n  this.type = 'VertexNormalsHelper'; //\n\n  this.matrixAutoUpdate = false;\n  this.update();\n}\n\nVertexNormalsHelper.prototype = Object.create(three__WEBPACK_IMPORTED_MODULE_0__[\"LineSegments\"].prototype);\nVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\nVertexNormalsHelper.prototype.update = function () {\n  var idx;\n  this.object.updateMatrixWorld(true);\n\n  _normalMatrix.getNormalMatrix(this.object.matrixWorld);\n\n  var matrixWorld = this.object.matrixWorld;\n  var position = this.geometry.attributes.position; //\n\n  var objGeometry = this.object.geometry;\n\n  if (objGeometry && objGeometry.isGeometry) {\n    var vertices = objGeometry.vertices;\n    var faces = objGeometry.faces;\n    idx = 0;\n\n    for (var i = 0, l = faces.length; i < l; i++) {\n      var face = faces[i];\n\n      for (var _j = 0, _jl = face.vertexNormals.length; _j < _jl; _j++) {\n        var vertex = vertices[face[_keys[_j]]];\n        var normal = face.vertexNormals[_j];\n\n        _v1.copy(vertex).applyMatrix4(matrixWorld);\n\n        _v2.copy(normal).applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n        idx = idx + 1;\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n        idx = idx + 1;\n      }\n    }\n  } else if (objGeometry && objGeometry.isBufferGeometry) {\n    var objPos = objGeometry.attributes.position;\n    var objNorm = objGeometry.attributes.normal;\n    idx = 0; // for simplicity, ignore index and drawcalls, and render every normal\n\n    for (var j = 0, jl = objPos.count; j < jl; j++) {\n      _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\n\n      _v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\n\n      _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n      position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n      idx = idx + 1;\n      position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n      idx = idx + 1;\n    }\n  }\n\n  position.needsUpdate = true;\n};\n\n\n\n//# sourceURL=webpack:///./src/js/app/helpers/vertexNormalsHelper.js?");

/***/ }),

/***/ "./src/js/app/loaders/GLTFLoader.js":
/*!******************************************!*\
  !*** ./src/js/app/loaders/GLTFLoader.js ***!
  \******************************************/
/*! exports provided: GLTFLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GLTFLoader\", function() { return GLTFLoader; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\n\nvar GLTFLoader = function () {\n  function GLTFLoader(manager) {\n    three__WEBPACK_IMPORTED_MODULE_0__[\"Loader\"].call(this, manager);\n    this.dracoLoader = null;\n    this.ddsLoader = null;\n  }\n\n  GLTFLoader.prototype = Object.assign(Object.create(three__WEBPACK_IMPORTED_MODULE_0__[\"Loader\"].prototype), {\n    constructor: GLTFLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].extractUrlBase(url);\n      } // Tells the LoadingManager to track an extra item, which resolves after\n      // the model is fully loaded. This means the count of items loaded will\n      // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n      scope.manager.itemStart(url);\n\n      var _onError = function _onError(e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      };\n\n      var loader = new three__WEBPACK_IMPORTED_MODULE_0__[\"FileLoader\"](scope.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n\n      if (scope.crossOrigin === 'use-credentials') {\n        loader.setWithCredentials(true);\n      }\n\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, resourcePath, function (gltf) {\n            onLoad(gltf);\n            scope.manager.itemEnd(url);\n          }, _onError);\n        } catch (e) {\n          _onError(e);\n        }\n      }, onProgress, _onError);\n    },\n    setDRACOLoader: function setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    },\n    setDDSLoader: function setDDSLoader(ddsLoader) {\n      this.ddsLoader = ddsLoader;\n      return this;\n    },\n    parse: function parse(data, path, onLoad, onError) {\n      var content;\n      var extensions = {};\n\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        var magic = three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].decodeText(new Uint8Array(data, 0, 4));\n\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].decodeText(new Uint8Array(data));\n        }\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\n        return;\n      }\n\n      if (json.extensionsUsed) {\n        for (var i = 0; i < json.extensionsUsed.length; ++i) {\n          var extensionName = json.extensionsUsed[i];\n          var extensionsRequired = json.extensionsRequired || [];\n\n          switch (extensionName) {\n            case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n              extensions[extensionName] = new GLTFLightsExtension(json);\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_CLEARCOAT:\n              extensions[extensionName] = new GLTFMaterialsClearcoatExtension();\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n              break;\n\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n              break;\n\n            case EXTENSIONS.MSFT_TEXTURE_DDS:\n              extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);\n              break;\n\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n              extensions[extensionName] = new GLTFTextureTransformExtension();\n              break;\n\n            case EXTENSIONS.KHR_MESH_QUANTIZATION:\n              extensions[extensionName] = new GLTFMeshQuantizationExtension();\n              break;\n\n            default:\n              if (extensionsRequired.indexOf(extensionName) >= 0) {\n                console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n              }\n\n          }\n        }\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        path: path || this.resourcePath || '',\n        crossOrigin: this.crossOrigin,\n        manager: this.manager\n      });\n      parser.parse(onLoad, onError);\n    }\n  });\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function get(key) {\n        return objects[key];\n      },\n      add: function add(key, object) {\n        objects[key] = object;\n      },\n      remove: function remove(key) {\n        delete objects[key];\n      },\n      removeAll: function removeAll() {\n        objects = {};\n      }\n    };\n  }\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n    KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n    KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n  };\n  /**\n   * DDS Texture Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n   *\n   */\n\n  function GLTFTextureDDSExtension(ddsLoader) {\n    if (!ddsLoader) {\n      throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader');\n    }\n\n    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n    this.ddsLoader = ddsLoader;\n  }\n  /**\n   * Punctual Lights Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n   */\n\n\n  function GLTFLightsExtension(json) {\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};\n    this.lightDefs = extension.lights || [];\n  }\n\n  GLTFLightsExtension.prototype.loadLight = function (lightIndex) {\n    var lightDef = this.lightDefs[lightIndex];\n    var lightNode;\n    var color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    var range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__[\"DirectionalLight\"](color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__[\"PointLight\"](color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__[\"SpotLight\"](color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".');\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = lightDef.name || 'light_' + lightIndex;\n    return Promise.resolve(lightNode);\n  };\n  /**\n   * Unlit Materials Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n   */\n\n\n  function GLTFMaterialsUnlitExtension() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n    return three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"];\n  };\n\n  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n    var pending = [];\n    materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    var metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /**\n   * Clearcoat Materials Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n   */\n\n\n  function GLTFMaterialsClearcoatExtension() {\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n\n  GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function () {\n    return three__WEBPACK_IMPORTED_MODULE_0__[\"MeshPhysicalMaterial\"];\n  };\n\n  GLTFMaterialsClearcoatExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n    var pending = [];\n    var extension = materialDef.extensions[this.name];\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        var scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](scale, scale);\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n  var BINARY_EXTENSION_HEADER_LENGTH = 12;\n  var BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4e4f534a,\n    BIN: 0x004e4942\n  };\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n    }\n\n    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    var chunkIndex = 0;\n\n    while (chunkIndex < chunkView.byteLength) {\n      var chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      var chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = three__WEBPACK_IMPORTED_MODULE_0__[\"LoaderUtils\"].decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n  /**\n   * DRACO Mesh Compression Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n   */\n\n\n  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n\n  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n    var json = this.json;\n    var dracoLoader = this.dracoLoader;\n    var bufferViewIndex = primitive.extensions[this.name].bufferView;\n    var gltfAttributeMap = primitive.extensions[this.name].attributes;\n    var threeAttributeMap = {};\n    var attributeNormalizedMap = {};\n    var attributeTypeMap = {};\n\n    for (var attributeName in gltfAttributeMap) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (attributeName in primitive.attributes) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        var accessorDef = json.accessors[primitive.attributes[attributeName]];\n        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (var attributeName in geometry.attributes) {\n            var attribute = geometry.attributes[attributeName];\n            var normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  };\n  /**\n   * Texture Transform Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n   */\n\n\n  function GLTFTextureTransformExtension() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    if (transform.texCoord !== undefined) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n  /**\n   * A sub class of StandardMaterial with some of the functionality\n   * changed via the `onBeforeCompile` callback\n   * @pailhead\n   */\n\n\n  function GLTFMeshStandardSGMaterial(params) {\n    three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"].call(this);\n    this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\n\n    var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n    var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n    var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n    var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n    var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n    var uniforms = {\n      specular: {\n        value: new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]().setHex(0xffffff)\n      },\n      glossiness: {\n        value: 1\n      },\n      specularMap: {\n        value: null\n      },\n      glossinessMap: {\n        value: null\n      }\n    };\n    this._extraUniforms = uniforms; // please see #14031 or #13198 for an alternate approach\n\n    this.onBeforeCompile = function (shader) {\n      for (var uniformName in uniforms) {\n        shader.uniforms[uniformName] = uniforms[uniformName];\n      }\n\n      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;');\n      shader.fragmentShader = shader.fragmentShader.replace('uniform float metalness;', 'uniform float glossiness;');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_fragment>', specularMapFragmentChunk);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n    };\n    /*eslint-disable*/\n\n\n    Object.defineProperties(this, {\n      specular: {\n        get: function get() {\n          return uniforms.specular.value;\n        },\n        set: function set(v) {\n          uniforms.specular.value = v;\n        }\n      },\n      specularMap: {\n        get: function get() {\n          return uniforms.specularMap.value;\n        },\n        set: function set(v) {\n          uniforms.specularMap.value = v;\n        }\n      },\n      glossiness: {\n        get: function get() {\n          return uniforms.glossiness.value;\n        },\n        set: function set(v) {\n          uniforms.glossiness.value = v;\n        }\n      },\n      glossinessMap: {\n        get: function get() {\n          return uniforms.glossinessMap.value;\n        },\n        set: function set(v) {\n          uniforms.glossinessMap.value = v; //how about something like this - @pailhead\n\n          if (v) {\n            this.defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv\n\n            this.defines.USE_ROUGHNESSMAP = '';\n          } else {\n            delete this.defines.USE_ROUGHNESSMAP;\n            delete this.defines.USE_GLOSSINESSMAP;\n          }\n        }\n      }\n    });\n    /*eslint-enable*/\n\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    this.setValues(params);\n  }\n\n  GLTFMeshStandardSGMaterial.prototype = Object.create(three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"].prototype);\n  GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\n\n  GLTFMeshStandardSGMaterial.prototype.copy = function (source) {\n    three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"].prototype.copy.call(this, source);\n    this.specularMap = source.specularMap;\n    this.specular.copy(source.specular);\n    this.glossinessMap = source.glossinessMap;\n    this.glossiness = source.glossiness;\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    return this;\n  };\n\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\n    return {\n      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n      getMaterialType: function getMaterialType() {\n        return GLTFMeshStandardSGMaterial;\n      },\n      extendParams: function extendParams(materialParams, materialDef, parser) {\n        var pbrSpecularGlossiness = materialDef.extensions[this.name];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n        var pending = [];\n\n        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n          var array = pbrSpecularGlossiness.diffuseFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n\n        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n        }\n\n        materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](0.0, 0.0, 0.0);\n        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n        materialParams.specular = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1.0, 1.0, 1.0);\n\n        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n        }\n\n        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n          pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n          pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n        }\n\n        return Promise.all(pending);\n      },\n      createMaterial: function createMaterial(materialParams) {\n        var material = new GLTFMeshStandardSGMaterial(materialParams);\n        material.fog = true;\n        material.color = materialParams.color;\n        material.map = materialParams.map === undefined ? null : materialParams.map;\n        material.lightMap = null;\n        material.lightMapIntensity = 1.0;\n        material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n        material.aoMapIntensity = 1.0;\n        material.emissive = materialParams.emissive;\n        material.emissiveIntensity = 1.0;\n        material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n        material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n        material.bumpScale = 1;\n        material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n        material.normalMapType = three__WEBPACK_IMPORTED_MODULE_0__[\"TangentSpaceNormalMap\"];\n        if (materialParams.normalScale) material.normalScale = materialParams.normalScale;\n        material.displacementMap = null;\n        material.displacementScale = 1;\n        material.displacementBias = 0;\n        material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n        material.specular = materialParams.specular;\n        material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n        material.glossiness = materialParams.glossiness;\n        material.alphaMap = null;\n        material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n        material.envMapIntensity = 1.0;\n        material.refractionRatio = 0.98;\n        return material;\n      }\n    };\n  }\n  /**\n   * Mesh Quantization Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n   */\n\n\n  function GLTFMeshQuantizationExtension() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n  /*********************************/\n\n  /********** INTERPOLATION ********/\n\n  /*********************************/\n  // Spline Interpolation\n  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    three__WEBPACK_IMPORTED_MODULE_0__[\"Interpolant\"].call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  GLTFCubicSplineInterpolant.prototype = Object.create(three__WEBPACK_IMPORTED_MODULE_0__[\"Interpolant\"].prototype);\n  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    var result = this.resultBuffer,\n        values = this.sampleValues,\n        valueSize = this.valueSize,\n        offset = index * valueSize * 3 + valueSize;\n\n    for (var i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  };\n\n  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n    var result = this.resultBuffer;\n    var values = this.sampleValues;\n    var stride = this.valueSize;\n    var stride2 = stride * 2;\n    var stride3 = stride * 3;\n    var td = t1 - t0;\n    var p = (t - t0) / td;\n    var pp = p * p;\n    var ppp = pp * p;\n    var offset1 = i1 * stride3;\n    var offset0 = offset1 - stride3;\n    var s2 = -2 * ppp + 3 * pp;\n    var s3 = ppp - pp;\n    var s0 = 1 - s2;\n    var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n    for (var i = 0; i !== stride; i++) {\n      var p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n\n    return result;\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"],\n    9729: three__WEBPACK_IMPORTED_MODULE_0__[\"LinearFilter\"],\n    9984: three__WEBPACK_IMPORTED_MODULE_0__[\"NearestMipmapNearestFilter\"],\n    9985: three__WEBPACK_IMPORTED_MODULE_0__[\"LinearMipmapNearestFilter\"],\n    9986: three__WEBPACK_IMPORTED_MODULE_0__[\"NearestMipmapLinearFilter\"],\n    9987: three__WEBPACK_IMPORTED_MODULE_0__[\"LinearMipmapLinearFilter\"]\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__[\"ClampToEdgeWrapping\"],\n    33648: three__WEBPACK_IMPORTED_MODULE_0__[\"MirroredRepeatWrapping\"],\n    10497: three__WEBPACK_IMPORTED_MODULE_0__[\"RepeatWrapping\"]\n  };\n  var WEBGL_TYPE_SIZES = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n  };\n  var ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex'\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion',\n    weights: 'morphTargetInfluences'\n  };\n  var INTERPOLATION = {\n    CUBICSPLINE: undefined,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__[\"InterpolateLinear\"],\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__[\"InterpolateDiscrete\"]\n  };\n  var ALPHA_MODES = {\n    OPAQUE: 'OPAQUE',\n    MASK: 'MASK',\n    BLEND: 'BLEND'\n  };\n  var MIME_TYPE_FORMATS = {\n    'image/png': three__WEBPACK_IMPORTED_MODULE_0__[\"RGBAFormat\"],\n    'image/jpeg': three__WEBPACK_IMPORTED_MODULE_0__[\"RGBFormat\"]\n  };\n  /* UTILITY FUNCTIONS */\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\n\n    if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n      // eslint-disable-next-line no-useless-escape\n      path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    } // Absolute URL http://,https://,//\n\n\n    if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n    if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n    return path + url;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n   */\n\n\n  function createDefaultMaterial(cache) {\n    if (cache['DefaultMaterial'] === undefined) {\n      cache['DefaultMaterial'] = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"]({\n        color: 0xffffff,\n        emissive: 0x000000,\n        metalness: 1,\n        roughness: 1,\n        transparent: false,\n        depthTest: true,\n        side: three__WEBPACK_IMPORTED_MODULE_0__[\"FrontSide\"]\n      });\n    }\n\n    return cache['DefaultMaterial'];\n  }\n\n  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    // Add unknown glTF extensions to an object's userData.\n    for (var name in objectDef.extensions) {\n      if (knownExtensions[name] === undefined) {\n        object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n        object.userData.gltfExtensions[name] = objectDef.extensions[name];\n      }\n    }\n  }\n  /**\n   * @param {Object3D|Material|BufferGeometry} object\n   * @param {GLTF.definition} gltfDef\n   */\n\n\n  function assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== undefined) {\n      if (_typeof(gltfDef.extras) === 'object') {\n        Object.assign(object.userData, gltfDef.extras);\n      } else {\n        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n      }\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n   *\n   * @param {BufferGeometry} geometry\n   * @param {Array<GLTF.Target>} targets\n   * @param {GLTFParser} parser\n   * @return {Promise<BufferGeometry>}\n   */\n\n\n  function addMorphTargets(geometry, targets, parser) {\n    var hasMorphPosition = false;\n    var hasMorphNormal = false;\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n      if (target.POSITION !== undefined) hasMorphPosition = true;\n      if (target.NORMAL !== undefined) hasMorphNormal = true;\n      if (hasMorphPosition && hasMorphNormal) break;\n    }\n\n    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n    var pendingPositionAccessors = [];\n    var pendingNormalAccessors = [];\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n\n      if (hasMorphPosition) {\n        var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n        pendingPositionAccessors.push(pendingAccessor);\n      }\n\n      if (hasMorphNormal) {\n        var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n        pendingNormalAccessors.push(pendingAccessor);\n      }\n    }\n\n    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n      var morphPositions = accessors[0];\n      var morphNormals = accessors[1];\n      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n      geometry.morphTargetsRelative = true;\n      return geometry;\n    });\n  }\n  /**\n   * @param {Mesh} mesh\n   * @param {GLTF.Mesh} meshDef\n   */\n\n\n  function updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n\n    if (meshDef.weights !== undefined) {\n      for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n        mesh.morphTargetInfluences[i] = meshDef.weights[i];\n      }\n    } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n      var targetNames = meshDef.extras.targetNames;\n\n      if (mesh.morphTargetInfluences.length === targetNames.length) {\n        mesh.morphTargetDictionary = {};\n\n        for (var i = 0, il = targetNames.length; i < il; i++) {\n          mesh.morphTargetDictionary[targetNames[i]] = i;\n        }\n      } else {\n        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n      }\n    }\n  }\n\n  function createPrimitiveKey(primitiveDef) {\n    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    var geometryKey;\n\n    if (dracoExtension) {\n      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n    } else {\n      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n    }\n\n    return geometryKey;\n  }\n\n  function createAttributesKey(attributes) {\n    var attributesKey = '';\n    var keys = Object.keys(attributes).sort();\n\n    for (var i = 0, il = keys.length; i < il; i++) {\n      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n    }\n\n    return attributesKey;\n  }\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry(); // BufferGeometry caching\n\n    this.primitiveCache = {};\n    this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__[\"TextureLoader\"](this.options.manager);\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__[\"FileLoader\"](this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  GLTFParser.prototype.parse = function (onLoad, onError) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this.markDefs();\n    Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {\n      var result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      onLoad(result);\n    })[\"catch\"](onError);\n  };\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  GLTFParser.prototype.markDefs = function () {\n    var nodeDefs = this.json.nodes || [];\n    var skinDefs = this.json.skins || [];\n    var meshDefs = this.json.meshes || [];\n    var meshReferences = {};\n    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      var joints = skinDefs[skinIndex].joints;\n\n      for (var i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n    // avoid having more than one Mesh with the same name, count\n    // references and rename instances below.\n    //\n    // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\n\n    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      var nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        if (meshReferences[nodeDef.mesh] === undefined) {\n          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n        }\n\n        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n    }\n\n    this.json.meshReferences = meshReferences;\n    this.json.meshUses = meshUses;\n  };\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  GLTFParser.prototype.getDependency = function (type, index) {\n    var cacheKey = type + ':' + index;\n    var dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this.loadMesh(index);\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this.loadBufferView(index);\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this.loadMaterial(index);\n          break;\n\n        case 'texture':\n          dependency = this.loadTexture(index);\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        case 'light':\n          dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  };\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  GLTFParser.prototype.getDependencies = function (type) {\n    var dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      var parser = this;\n      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n    var bufferDef = this.json.buffers[bufferIndex];\n    var loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    var options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n    var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      var byteLength = bufferViewDef.byteLength || 0;\n      var byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n\n\n  GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n    var parser = this;\n    var json = this.json;\n    var accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    var pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      var bufferView = bufferViews[0];\n      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      var itemBytes = elementBytes * itemSize;\n      var byteOffset = accessorDef.byteOffset || 0;\n      var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      var normalized = accessorDef.normalized === true;\n      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        var ibSlice = Math.floor(byteOffset / byteStride);\n        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n        var ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new three__WEBPACK_IMPORTED_MODULE_0__[\"InterleavedBuffer\"](array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__[\"InterleavedBufferAttribute\"](ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"](array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"](bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n\n        for (var i = 0, il = sparseIndices.length; i < il; i++) {\n          var index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  GLTFParser.prototype.loadTexture = function (textureIndex) {\n    var parser = this;\n    var json = this.json;\n    var options = this.options;\n    var textureLoader = this.textureLoader;\n    var URL = self.URL || self.webkitURL;\n    var textureDef = json.textures[textureIndex];\n    var textureExtensions = textureDef.extensions || {};\n    var source;\n\n    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n    } else {\n      source = json.images[textureDef.source];\n    }\n\n    var sourceURI = source.uri;\n    var isObjectURL = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        var blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    }\n\n    return Promise.resolve(sourceURI).then(function (sourceURI) {\n      // Load Texture resource.\n      var loader = options.manager.getHandler(sourceURI);\n\n      if (!loader) {\n        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n      }\n\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.\n\n      if (source.mimeType in MIME_TYPE_FORMATS) {\n        texture.format = MIME_TYPE_FORMATS[source.mimeType];\n      }\n\n      var samplers = json.samplers || {};\n      var sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__[\"LinearFilter\"];\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__[\"LinearMipmapLinearFilter\"];\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__[\"RepeatWrapping\"];\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__[\"RepeatWrapping\"];\n      return texture;\n    });\n  };\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise}\n   */\n\n\n  GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {\n    var parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture.isCompressedTexture) {\n        switch (mapName) {\n          case 'aoMap':\n          case 'emissiveMap':\n          case 'metalnessMap':\n          case 'normalMap':\n          case 'roughnessMap':\n            texture.format = three__WEBPACK_IMPORTED_MODULE_0__[\"RGBFormat\"];\n            break;\n        }\n      } // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n      // However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\n        console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n        }\n      }\n\n      materialParams[mapName] = texture;\n    });\n  };\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accomodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  GLTFParser.prototype.assignFinalMaterial = function (mesh) {\n    var geometry = mesh.geometry;\n    var material = mesh.material;\n    var useVertexTangents = geometry.attributes.tangent !== undefined;\n    var useVertexColors = geometry.attributes.color !== undefined;\n    var useFlatShading = geometry.attributes.normal === undefined;\n    var useSkinning = mesh.isSkinnedMesh === true;\n    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n    if (mesh.isPoints) {\n      var cacheKey = 'PointsMaterial:' + material.uuid;\n      var pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"PointsMaterial\"]();\n        three__WEBPACK_IMPORTED_MODULE_0__[\"Material\"].prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      var cacheKey = 'LineBasicMaterial:' + material.uuid;\n      var lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineBasicMaterial\"]();\n        three__WEBPACK_IMPORTED_MODULE_0__[\"Material\"].prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n      var cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useSkinning) cacheKey += 'skinning:';\n      if (useVertexTangents) cacheKey += 'vertex-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      if (useMorphTargets) cacheKey += 'morph-targets:';\n      if (useMorphNormals) cacheKey += 'morph-normals:';\n      var cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useSkinning) cachedMaterial.skinning = true;\n        if (useVertexTangents) cachedMaterial.vertexTangents = true;\n        if (useVertexColors) cachedMaterial.vertexColors = true;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useMorphTargets) cachedMaterial.morphTargets = true;\n        if (useMorphNormals) cachedMaterial.morphNormals = true;\n        this.cache.add(cacheKey, cachedMaterial);\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      geometry.setAttribute('uv2', geometry.attributes.uv);\n    } // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n\n    if (material.normalScale && !useVertexTangents) {\n      material.normalScale.y = -material.normalScale.y;\n    }\n\n    if (material.clearcoatNormalScale && !useVertexTangents) {\n      material.clearcoatNormalScale.y = -material.clearcoatNormalScale.y;\n    }\n\n    mesh.material = material;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n\n\n  GLTFParser.prototype.loadMaterial = function (materialIndex) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions;\n    var materialDef = json.materials[materialIndex];\n    var materialType;\n    var materialParams = {};\n    var materialExtensions = materialDef.extensions || {};\n    var pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      materialType = three__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"];\n      var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"](1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"];\n    }\n\n    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\n\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n      materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]) {\n      materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__[\"Color\"]().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n    }\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_CLEARCOAT]) {\n      var clearcoatExtension = extensions[EXTENSIONS.KHR_MATERIALS_CLEARCOAT];\n      materialType = clearcoatExtension.getMaterialType();\n      pending.push(clearcoatExtension.extendParams(materialParams, {\n        extensions: materialExtensions\n      }, parser));\n    }\n\n    return Promise.all(pending).then(function () {\n      var material;\n\n      if (materialType === GLTFMeshStandardSGMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n      if (material.map) material.map.encoding = three__WEBPACK_IMPORTED_MODULE_0__[\"sRGBEncoding\"];\n      if (material.emissiveMap) material.emissiveMap.encoding = three__WEBPACK_IMPORTED_MODULE_0__[\"sRGBEncoding\"];\n      assignExtrasToUserData(material, materialDef);\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  };\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {GLTFParser} parser\n   */\n\n\n  function computeBounds(geometry, primitiveDef, parser) {\n    var attributes = primitiveDef.attributes;\n    var box = new three__WEBPACK_IMPORTED_MODULE_0__[\"Box3\"]();\n\n    if (attributes.POSITION !== undefined) {\n      var accessor = parser.json.accessors[attributes.POSITION];\n      var min = accessor.min;\n      var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n      if (min !== undefined && max !== undefined) {\n        box.set(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](max[0], max[1], max[2]));\n      } else {\n        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n        return;\n      }\n    } else {\n      return;\n    }\n\n    var targets = primitiveDef.targets;\n\n    if (targets !== undefined) {\n      var maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n      var vector = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n\n      for (var i = 0, il = targets.length; i < il; i++) {\n        var target = targets[i];\n\n        if (target.POSITION !== undefined) {\n          var accessor = parser.json.accessors[target.POSITION];\n          var min = accessor.min;\n          var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n          if (min !== undefined && max !== undefined) {\n            // we need to get max of absolute components because target weight is [-1,1]\n            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2]))); // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n            // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n            // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n            // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\n            maxDisplacement.max(vector);\n          } else {\n            console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n          }\n        }\n      } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\n\n      box.expandByVector(maxDisplacement);\n    }\n\n    geometry.boundingBox = box;\n    var sphere = new three__WEBPACK_IMPORTED_MODULE_0__[\"Sphere\"]();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n  }\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {GLTFParser} parser\n   * @return {Promise<BufferGeometry>}\n   */\n\n\n  function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    var attributes = primitiveDef.attributes;\n    var pending = [];\n\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n        geometry.setAttribute(attributeName, accessor);\n      });\n    }\n\n    for (var gltfAttributeName in attributes) {\n      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n      if (threeAttributeName in geometry.attributes) continue;\n      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n        geometry.setIndex(accessor);\n      });\n      pending.push(accessor);\n    }\n\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function () {\n      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n  }\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {Number} drawMode\n   * @return {BufferGeometry}\n   */\n\n\n  function toTrianglesDrawMode(geometry, drawMode) {\n    var index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      var indices = [];\n      var position = geometry.getAttribute('position');\n\n      if (position !== undefined) {\n        for (var i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n\n    var numberOfTriangles = index.count - 2;\n    var newIndices = [];\n\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleFanDrawMode\"]) {\n      // gl.TRIANGLE_FAN\n      for (var i = 1; i <= numberOfTriangles; i++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n      for (var i = 0; i < numberOfTriangles; i++) {\n        if (i % 2 === 0) {\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i + 2));\n        } else {\n          newIndices.push(index.getX(i + 2));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i));\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n\n    var newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    return newGeometry;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n\n\n  GLTFParser.prototype.loadGeometries = function (primitives) {\n    var parser = this;\n    var extensions = this.extensions;\n    var cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var primitive = primitives[i];\n      var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      var cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        var geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"](), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n\n\n  GLTFParser.prototype.loadMesh = function (meshIndex) {\n    var parser = this;\n    var json = this.json;\n    var meshDef = json.meshes[meshIndex];\n    var primitives = meshDef.primitives;\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function (results) {\n      var materials = results.slice(0, results.length - 1);\n      var geometries = results[results.length - 1];\n      var meshes = [];\n\n      for (var i = 0, il = geometries.length; i < il; i++) {\n        var geometry = geometries[i];\n        var primitive = primitives[i]; // 1. create Mesh\n\n        var mesh;\n        var material = materials[i];\n\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n          // .isSkinnedMesh isn't in glTF spec. See .markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__[\"SkinnedMesh\"](geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, material);\n\n          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n            // we normalize floating point skin weight array to fix malformed assets (see #15319)\n            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n            mesh.normalizeSkinWeights();\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleStripDrawMode\"]);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleFanDrawMode\"]);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineSegments\"](geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Line\"](geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineLoop\"](geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__[\"Points\"](geometry, material);\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n\n        mesh.name = meshDef.name || 'mesh_' + meshIndex;\n        if (geometries.length > 1) mesh.name += '_' + i;\n        assignExtrasToUserData(mesh, meshDef);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n\n      if (meshes.length === 1) {\n        return meshes[0];\n      }\n\n      var group = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\n\n      for (var i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n\n      return group;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  GLTFParser.prototype.loadCamera = function (cameraIndex) {\n    var camera;\n    var cameraDef = this.json.cameras[cameraIndex];\n    var params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"](three__WEBPACK_IMPORTED_MODULE_0__[\"MathUtils\"].radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicCamera\"](-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name) camera.name = cameraDef.name;\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  GLTFParser.prototype.loadSkin = function (skinIndex) {\n    var skinDef = this.json.skins[skinIndex];\n    var skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n\n\n  GLTFParser.prototype.loadAnimation = function (animationIndex) {\n    var json = this.json;\n    var animationDef = json.animations[animationIndex];\n    var pendingNodes = [];\n    var pendingInputAccessors = [];\n    var pendingOutputAccessors = [];\n    var pendingSamplers = [];\n    var pendingTargets = [];\n\n    for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n      var channel = animationDef.channels[i];\n      var sampler = animationDef.samplers[channel.sampler];\n      var target = channel.target;\n      var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n      var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      var nodes = dependencies[0];\n      var inputAccessors = dependencies[1];\n      var outputAccessors = dependencies[2];\n      var samplers = dependencies[3];\n      var targets = dependencies[4];\n      var tracks = [];\n\n      for (var i = 0, il = nodes.length; i < il; i++) {\n        var node = nodes[i];\n        var inputAccessor = inputAccessors[i];\n        var outputAccessor = outputAccessors[i];\n        var sampler = samplers[i];\n        var target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        var TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__[\"NumberKeyframeTrack\"];\n            break;\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__[\"QuaternionKeyframeTrack\"];\n            break;\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__[\"VectorKeyframeTrack\"];\n            break;\n        }\n\n        var targetName = node.name ? node.name : node.uuid;\n        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__[\"InterpolateLinear\"];\n        var targetNames = [];\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          // Node may be a Group (glTF mesh with several primitives) or a Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        var outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          var scale;\n\n          if (outputArray.constructor === Int8Array) {\n            scale = 1 / 127;\n          } else if (outputArray.constructor === Uint8Array) {\n            scale = 1 / 255;\n          } else if (outputArray.constructor == Int16Array) {\n            scale = 1 / 32767;\n          } else if (outputArray.constructor === Uint16Array) {\n            scale = 1 / 65535;\n          } else {\n            throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');\n          }\n\n          var scaled = new Float32Array(outputArray.length);\n\n          for (var j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (var j = 0, jl = targetNames.length; j < jl; j++) {\n          var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n      return new three__WEBPACK_IMPORTED_MODULE_0__[\"AnimationClip\"](name, undefined, tracks);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n\n\n  GLTFParser.prototype.loadNode = function (nodeIndex) {\n    var json = this.json;\n    var extensions = this.extensions;\n    var parser = this;\n    var meshReferences = json.meshReferences;\n    var meshUses = json.meshUses;\n    var nodeDef = json.nodes[nodeIndex];\n    return function () {\n      var pending = [];\n\n      if (nodeDef.mesh !== undefined) {\n        pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n          var node;\n\n          if (meshReferences[nodeDef.mesh] > 1) {\n            var instanceNum = meshUses[nodeDef.mesh]++;\n            node = mesh.clone();\n            node.name += '_instance_' + instanceNum;\n          } else {\n            node = mesh;\n          } // if weights are provided on the node, override weights on the mesh.\n\n\n          if (nodeDef.weights !== undefined) {\n            node.traverse(function (o) {\n              if (!o.isMesh) return;\n\n              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n                o.morphTargetInfluences[i] = nodeDef.weights[i];\n              }\n            });\n          }\n\n          return node;\n        }));\n      }\n\n      if (nodeDef.camera !== undefined) {\n        pending.push(parser.getDependency('camera', nodeDef.camera));\n      }\n\n      if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {\n        pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));\n      }\n\n      return Promise.all(pending);\n    }().then(function (objects) {\n      var node; // .isBone isn't in glTF spec. See .markDefs\n\n      if (nodeDef.isBone === true) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__[\"Bone\"]();\n      } else if (objects.length > 1) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\n      }\n\n      if (node !== objects[0]) {\n        for (var i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = three__WEBPACK_IMPORTED_MODULE_0__[\"PropertyBinding\"].sanitizeNodeName(nodeDef.name);\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        var matrix = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      return node;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n\n\n  GLTFParser.prototype.loadScene = function () {\n    // scene node hierachy builder\n    function buildNodeHierachy(nodeId, parentObject, json, parser) {\n      var nodeDef = json.nodes[nodeId];\n      return parser.getDependency('node', nodeId).then(function (node) {\n        if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n        var skinEntry;\n        return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n          skinEntry = skin;\n          var pendingJoints = [];\n\n          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n            pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n          }\n\n          return Promise.all(pendingJoints);\n        }).then(function (jointNodes) {\n          node.traverse(function (mesh) {\n            if (!mesh.isMesh) return;\n            var bones = [];\n            var boneInverses = [];\n\n            for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n              var jointNode = jointNodes[j];\n\n              if (jointNode) {\n                bones.push(jointNode);\n                var mat = new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]();\n\n                if (skinEntry.inverseBindMatrices !== undefined) {\n                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n                }\n\n                boneInverses.push(mat);\n              } else {\n                console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n              }\n            }\n\n            mesh.bind(new three__WEBPACK_IMPORTED_MODULE_0__[\"Skeleton\"](bones, boneInverses), mesh.matrixWorld);\n          });\n          return node;\n        });\n      }).then(function (node) {\n        // build node hierachy\n        parentObject.add(node);\n        var pending = [];\n\n        if (nodeDef.children) {\n          var children = nodeDef.children;\n\n          for (var i = 0, il = children.length; i < il; i++) {\n            var child = children[i];\n            pending.push(buildNodeHierachy(child, node, json, parser));\n          }\n        }\n\n        return Promise.all(pending);\n      });\n    }\n\n    return function loadScene(sceneIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var sceneDef = this.json.scenes[sceneIndex];\n      var parser = this; // Loader returns Group, not Scene.\n      // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\n      var scene = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\n      if (sceneDef.name) scene.name = sceneDef.name;\n      assignExtrasToUserData(scene, sceneDef);\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n      var nodeIds = sceneDef.nodes || [];\n      var pending = [];\n\n      for (var i = 0, il = nodeIds.length; i < il; i++) {\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n      }\n\n      return Promise.all(pending).then(function () {\n        return scene;\n      });\n    };\n  }();\n\n  return GLTFLoader;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/loaders/GLTFLoader.js?");

/***/ }),

/***/ "./src/js/app/main.js":
/*!****************************!*\
  !*** ./src/js/app/main.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Main; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n/* harmony import */ var _components_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/renderer */ \"./src/js/app/components/renderer.js\");\n/* harmony import */ var _components_camera__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/camera */ \"./src/js/app/components/camera.js\");\n/* harmony import */ var _components_light__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/light */ \"./src/js/app/components/light.js\");\n/* harmony import */ var _components_controls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/controls */ \"./src/js/app/components/controls.js\");\n/* harmony import */ var _components_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/geometry */ \"./src/js/app/components/geometry.js\");\n/* harmony import */ var _helpers_stats__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers/stats */ \"./src/js/app/helpers/stats.js\");\n/* harmony import */ var _helpers_meshHelper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers/meshHelper */ \"./src/js/app/helpers/meshHelper.js\");\n/* harmony import */ var _model_texture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./model/texture */ \"./src/js/app/model/texture.js\");\n/* harmony import */ var _model_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./model/model */ \"./src/js/app/model/model.js\");\n/* harmony import */ var _managers_interaction__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./managers/interaction */ \"./src/js/app/managers/interaction.js\");\n/* harmony import */ var _managers_datGUI__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./managers/datGUI */ \"./src/js/app/managers/datGUI.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Global imports -\n\n // Local imports -\n// Components\n\n\n\n\n\n // Helpers\n\n\n // Model\n\n\n // Managers\n\n\n // data\n\n // -- End of imports\n// This class instantiates and ties all of the components together, starts the loading process and renders the main loop\n\nvar Main = /*#__PURE__*/function () {\n  function Main(container) {\n    var _this = this;\n\n    _classCallCheck(this, Main);\n\n    // Set container property to container element\n    this.container = container; // Start Three clock\n\n    this.clock = new three__WEBPACK_IMPORTED_MODULE_0__[\"Clock\"](); // Main scene creation\n\n    this.scene = new three__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]();\n    this.scene.fog = new three__WEBPACK_IMPORTED_MODULE_0__[\"FogExp2\"](_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fog.color, _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].fog.near); // Get Device Pixel Ratio first for retina\n\n    if (window.devicePixelRatio) {\n      _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].dpr = window.devicePixelRatio;\n    } // Main renderer constructor\n\n\n    this.renderer = new _components_renderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.scene, container); // Components instantiations\n\n    this.camera = new _components_camera__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.renderer.threeRenderer);\n    this.controls = new _components_controls__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.camera.threeCamera, container);\n    this.light = new _components_light__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.scene); // Create and place lights in scene\n\n    var lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach(function (light) {\n      return _this.light.place(light);\n    }); // Create and place geo in scene\n\n    this.geometry = new _components_geometry__WEBPACK_IMPORTED_MODULE_6__[\"default\"](this.scene);\n    this.geometry.make('plane')(150, 150, 10, 10);\n    this.geometry.place([0, -20, 0], [Math.PI / 2, 0, 0]); // Set up rStats if dev environment\n\n    if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev && _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isShowingStats) {\n      this.stats = new _helpers_stats__WEBPACK_IMPORTED_MODULE_7__[\"default\"](this.renderer);\n      this.stats.setUp();\n    } // Set up gui\n\n\n    if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev) {\n      this.gui = new _managers_datGUI__WEBPACK_IMPORTED_MODULE_12__[\"default\"](this);\n    } // Instantiate texture class\n\n\n    this.texture = new _model_texture__WEBPACK_IMPORTED_MODULE_9__[\"default\"](); // Start loading the textures and then go on to load the model after the texture Promises have resolved\n\n    this.texture.load().then(function () {\n      _this.manager = new three__WEBPACK_IMPORTED_MODULE_0__[\"LoadingManager\"](); // Textures loaded, load model\n\n      _this.model = new _model_model__WEBPACK_IMPORTED_MODULE_10__[\"default\"](_this.scene, _this.manager, _this.texture.textures);\n\n      _this.model.load(_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].models[_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].model.selected].type); // onProgress callback\n\n\n      _this.manager.onProgress = function (item, loaded, total) {\n        console.log(\"\".concat(item, \": \").concat(loaded, \" \").concat(total));\n      }; // All loaders done now\n\n\n      _this.manager.onLoad = function () {\n        // Set up interaction manager with the app now that the model is finished loading\n        new _managers_interaction__WEBPACK_IMPORTED_MODULE_11__[\"default\"](_this.renderer.threeRenderer, _this.scene, _this.camera.threeCamera, _this.controls.threeControls); // Add dat.GUI controls if dev\n\n        if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev) {\n          _this.meshHelper = new _helpers_meshHelper__WEBPACK_IMPORTED_MODULE_8__[\"default\"](_this.scene, _this.model.obj);\n          if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].mesh.enableHelper) _this.meshHelper.enable();\n\n          _this.gui.load(_this, _this.model.obj);\n        } // Everything is now fully loaded\n\n\n        _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isLoaded = true;\n        _this.container.querySelector('#loading').style.display = 'none';\n      };\n    }); // Start render which does not wait for model fully loaded\n\n    this.render();\n  }\n\n  _createClass(Main, [{\n    key: \"render\",\n    value: function render() {\n      // Render rStats if Dev\n      if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev && _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isShowingStats) {\n        _helpers_stats__WEBPACK_IMPORTED_MODULE_7__[\"default\"].start();\n      } // Call render function and pass in created scene and camera\n\n\n      this.renderer.render(this.scene, this.camera.threeCamera); // rStats has finished determining render call now\n\n      if (_data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isDev && _data_config__WEBPACK_IMPORTED_MODULE_13__[\"default\"].isShowingStats) {\n        _helpers_stats__WEBPACK_IMPORTED_MODULE_7__[\"default\"].end();\n      } // Delta time is sometimes needed for certain updates\n      //const delta = this.clock.getDelta();\n      // Call any vendor or module frame updates here\n\n\n      _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].update();\n      this.controls.threeControls.update(); // RAF\n\n      requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n    }\n  }]);\n\n  return Main;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/main.js?");

/***/ }),

/***/ "./src/js/app/managers/datGUI.js":
/*!***************************************!*\
  !*** ./src/js/app/managers/datGUI.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DatGUI; });\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n // Manages all dat.GUI interactions\n\nvar DatGUI = /*#__PURE__*/function () {\n  function DatGUI(main) {\n    _classCallCheck(this, DatGUI);\n\n    this.gui = new dat.GUI();\n    this.camera = main.camera.threeCamera;\n    this.controls = main.controls.threeControls;\n    this.light = main.light;\n    this.scene = main.scene;\n    this.model = null;\n    this.meshHelper = null;\n  }\n\n  _createClass(DatGUI, [{\n    key: \"load\",\n    value: function load(main, mesh) {\n      var _this = this;\n\n      /* Global */\n      //this.gui.close();\n      this.model = main.model;\n      this.meshHelper = main.meshHelper;\n      /* Camera */\n\n      var cameraFolder = this.gui.addFolder('Camera');\n      var cameraFOVGui = cameraFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].camera, 'fov', 0, 180).name('Camera FOV');\n      cameraFOVGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.camera.fov = value;\n      });\n      cameraFOVGui.onFinishChange(function () {\n        _this.camera.updateProjectionMatrix();\n\n        _this.controls.enableRotate = true;\n      });\n      var cameraAspectGui = cameraFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].camera, 'aspect', 0, 4).name('Camera Aspect');\n      cameraAspectGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.camera.aspect = value;\n      });\n      cameraAspectGui.onFinishChange(function () {\n        _this.camera.updateProjectionMatrix();\n\n        _this.controls.enableRotate = true;\n      });\n      var cameraFogColorGui = cameraFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fog, 'color').name('Fog Color');\n      cameraFogColorGui.onChange(function (value) {\n        _this.scene.fog.color.setHex(value);\n      });\n      var cameraFogNearGui = cameraFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fog, 'near', 0.000, 0.010).name('Fog Near');\n      cameraFogNearGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.scene.fog.density = value;\n      });\n      cameraFogNearGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      /* Controls */\n\n      var controlsFolder = this.gui.addFolder('Controls');\n      controlsFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].controls, 'autoRotate').name('Auto Rotate').onChange(function (value) {\n        _this.controls.autoRotate = value;\n      });\n      var controlsAutoRotateSpeedGui = controlsFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].controls, 'autoRotateSpeed', -1, 1).name('Rotation Speed');\n      controlsAutoRotateSpeedGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.controls.autoRotateSpeed = value;\n      });\n      controlsAutoRotateSpeedGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      /* Model */\n\n      var modelFolder = this.gui.addFolder('Model');\n      modelFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].model, 'type', _toConsumableArray(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].model.initialTypes)).name('Select Model').onChange(function (value) {\n        if (value) {\n          if (_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.enableHelper) _this.meshHelper.disable();\n          _data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].model.selected = _data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].model.initialTypes.indexOf(value);\n\n          _this.unload();\n\n          _this.model.unload();\n\n          _this.model.load(value);\n        }\n      });\n      /* Mesh */\n\n      var meshFolder = this.gui.addFolder('Mesh');\n      meshFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh, 'enableHelper', true).name('Enable Helpers').onChange(function (value) {\n        if (value) {\n          _this.meshHelper.enable();\n        } else {\n          _this.meshHelper.disable();\n        }\n      });\n      meshFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh, 'translucent', true).name('Translucent').onChange(function (value) {\n        if (value) {\n          mesh.material.transparent = true;\n          mesh.material.opacity = 0.5;\n        } else {\n          mesh.material.opacity = 1.0;\n        }\n      });\n      meshFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh, 'wireframe', true).name('Wireframe').onChange(function (value) {\n        mesh.material.wireframe = value;\n      });\n      /* Lights */\n      // Ambient Light\n\n      var ambientLightFolder = this.gui.addFolder('Ambient Light');\n      ambientLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ambientLight, 'enabled').name('Enabled').onChange(function (value) {\n        _this.light.ambientLight.visible = value;\n      });\n      ambientLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ambientLight, 'color').name('Color').onChange(function (value) {\n        _this.light.ambientLight.color.setHex(value);\n      }); // Directional Light\n\n      var directionalLightFolder = this.gui.addFolder('Directional Light');\n      directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'enabled').name('Enabled').onChange(function (value) {\n        _this.light.directionalLight.visible = value;\n      });\n      directionalLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'color').name('Color').onChange(function (value) {\n        _this.light.directionalLight.color.setHex(value);\n      });\n      var directionalLightIntensityGui = directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'intensity', 0, 2).name('Intensity');\n      directionalLightIntensityGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.intensity = value;\n      });\n      directionalLightIntensityGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var directionalLightPositionXGui = directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'x', -1000, 1000).name('Position X');\n      directionalLightPositionXGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.position.x = value;\n      });\n      directionalLightPositionXGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var directionalLightPositionYGui = directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'y', -1000, 1000).name('Position Y');\n      directionalLightPositionYGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.position.y = value;\n      });\n      directionalLightPositionYGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var directionalLightPositionZGui = directionalLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].directionalLight, 'z', -1000, 1000).name('Position Z');\n      directionalLightPositionZGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.position.z = value;\n      });\n      directionalLightPositionZGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      }); // Shadow Map\n\n      var shadowFolder = this.gui.addFolder('Shadow Map');\n      shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'enabled').name('Enabled').onChange(function (value) {\n        _this.light.directionalLight.castShadow = value;\n      });\n      shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'helperEnabled').name('Helper Enabled').onChange(function (value) {\n        _this.light.directionalLightHelper.visible = value;\n      });\n      var shadowNearGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'near', 0, 400).name('Near');\n      shadowNearGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.shadow.camera.near = value;\n      });\n      shadowNearGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n\n        _this.light.directionalLight.shadow.map.dispose();\n\n        _this.light.directionalLight.shadow.map = null;\n\n        _this.light.directionalLightHelper.update();\n      });\n      var shadowFarGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'far', 0, 1200).name('Far');\n      shadowFarGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.shadow.camera.far = value;\n      });\n      shadowFarGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n\n        _this.light.directionalLight.shadow.map.dispose();\n\n        _this.light.directionalLight.shadow.map = null;\n\n        _this.light.directionalLightHelper.update();\n      });\n      var shadowTopGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'top', -400, 400).name('Top');\n      shadowTopGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.shadow.camera.top = value;\n      });\n      shadowTopGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n\n        _this.light.directionalLight.shadow.map.dispose();\n\n        _this.light.directionalLight.shadow.map = null;\n\n        _this.light.directionalLightHelper.update();\n      });\n      var shadowRightGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'right', -400, 400).name('Right');\n      shadowRightGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.shadow.camera.right = value;\n      });\n      shadowRightGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n\n        _this.light.directionalLight.shadow.map.dispose();\n\n        _this.light.directionalLight.shadow.map = null;\n\n        _this.light.directionalLightHelper.update();\n      });\n      var shadowBottomGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'bottom', -400, 400).name('Bottom');\n      shadowBottomGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.shadow.camera.bottom = value;\n      });\n      shadowBottomGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n\n        _this.light.directionalLight.shadow.map.dispose();\n\n        _this.light.directionalLight.shadow.map = null;\n\n        _this.light.directionalLightHelper.update();\n      });\n      var shadowLeftGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'left', -400, 400).name('Left');\n      shadowLeftGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.shadow.camera.left = value;\n      });\n      shadowLeftGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n\n        _this.light.directionalLight.shadow.map.dispose();\n\n        _this.light.directionalLight.shadow.map = null;\n\n        _this.light.directionalLightHelper.update();\n      });\n      var shadowBiasGui = shadowFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shadow, 'bias', -0.000010, 1).name('Bias');\n      shadowBiasGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.directionalLight.shadow.bias = value;\n      });\n      shadowBiasGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n\n        _this.light.directionalLight.shadow.map.dispose();\n\n        _this.light.directionalLight.shadow.map = null;\n\n        _this.light.directionalLightHelper.update();\n      }); // Point Light\n\n      var pointLightFolder = this.gui.addFolder('Point Light');\n      pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'enabled').name('Enabled').onChange(function (value) {\n        _this.light.pointLight.visible = value;\n      });\n      pointLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'color').name('Color').onChange(function (value) {\n        _this.light.pointLight.color.setHex(value);\n      });\n      var pointLightIntensityGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'intensity', 0, 2).name('Intensity');\n      pointLightIntensityGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.pointLight.intensity = value;\n      });\n      pointLightIntensityGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var pointLightDistanceGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'distance', 0, 1000).name('Distance');\n      pointLightDistanceGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.pointLight.distance = value;\n      });\n      pointLightDistanceGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var pointLightPositionXGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'x', -1000, 1000).name('Position X');\n      pointLightPositionXGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.pointLight.position.x = value;\n      });\n      pointLightPositionXGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var pointLightPositionYGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'y', -1000, 1000).name('Position Y');\n      pointLightPositionYGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.pointLight.position.y = value;\n      });\n      pointLightPositionYGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var pointLightPositionZGui = pointLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].pointLight, 'z', -1000, 1000).name('Position Z');\n      pointLightPositionZGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.pointLight.position.z = value;\n      });\n      pointLightPositionZGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      }); // Hemi Light\n\n      var hemiLightFolder = this.gui.addFolder('Hemi Light');\n      hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'enabled').name('Enabled').onChange(function (value) {\n        _this.light.hemiLight.visible = value;\n      });\n      hemiLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'color').name('Color').onChange(function (value) {\n        _this.light.hemiLight.color.setHex(value);\n      });\n      hemiLightFolder.addColor(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'groundColor').name('ground Color').onChange(function (value) {\n        _this.light.hemiLight.groundColor.setHex(value);\n      });\n      var hemiLightIntensityGui = hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'intensity', 0, 2).name('Intensity');\n      hemiLightIntensityGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.hemiLight.intensity = value;\n      });\n      hemiLightIntensityGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var hemiLightPositionXGui = hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'x', -1000, 1000).name('Position X');\n      hemiLightPositionXGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.hemiLight.position.x = value;\n      });\n      hemiLightPositionXGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var hemiLightPositionYGui = hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'y', -500, 1000).name('Position Y');\n      hemiLightPositionYGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.hemiLight.position.y = value;\n      });\n      hemiLightPositionYGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n      var hemiLightPositionZGui = hemiLightFolder.add(_data_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hemiLight, 'z', -1000, 1000).name('Position Z');\n      hemiLightPositionZGui.onChange(function (value) {\n        _this.controls.enableRotate = false;\n        _this.light.hemiLight.position.z = value;\n      });\n      hemiLightPositionZGui.onFinishChange(function () {\n        _this.controls.enableRotate = true;\n      });\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      this.gui.destroy();\n      this.gui = new dat.GUI();\n    }\n  }]);\n\n  return DatGUI;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/managers/datGUI.js?");

/***/ }),

/***/ "./src/js/app/managers/interaction.js":
/*!********************************************!*\
  !*** ./src/js/app/managers/interaction.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Interaction; });\n/* harmony import */ var _utils_keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/keyboard */ \"./src/js/utils/keyboard.js\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/helpers */ \"./src/js/utils/helpers.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n // Manages all input interactions\n\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(renderer, scene, camera, controls) {\n    var _this = this;\n\n    _classCallCheck(this, Interaction);\n\n    // Properties\n    this.renderer = renderer;\n    this.scene = scene;\n    this.camera = camera;\n    this.controls = controls;\n    this.timeout = null; // Instantiate keyboard helper\n\n    this.keyboard = new _utils_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"default\"](); // Listeners\n    // Mouse events\n\n    this.renderer.domElement.addEventListener('mousemove', function (event) {\n      return _utils_helpers__WEBPACK_IMPORTED_MODULE_1__[\"default\"].throttle(_this.onMouseMove(event), 250);\n    }, false);\n    this.renderer.domElement.addEventListener('mouseleave', function (event) {\n      return _this.onMouseLeave(event);\n    }, false);\n    this.renderer.domElement.addEventListener('mouseover', function (event) {\n      return _this.onMouseOver(event);\n    }, false); // Keyboard events\n\n    this.keyboard.domElement.addEventListener('keydown', function (event) {\n      // Only once\n      if (event.repeat) {\n        return;\n      }\n\n      if (_this.keyboard.eventMatches(event, 'escape')) {\n        console.log('Escape pressed');\n      }\n    });\n  }\n\n  _createClass(Interaction, [{\n    key: \"onMouseOver\",\n    value: function onMouseOver(event) {\n      event.preventDefault();\n      _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isMouseOver = true;\n    }\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave(event) {\n      event.preventDefault();\n      _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isMouseOver = false;\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      event.preventDefault();\n      clearTimeout(this.timeout);\n      this.timeout = setTimeout(function () {\n        _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isMouseMoving = false;\n      }, 200);\n      _data_config__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isMouseMoving = true;\n    }\n  }]);\n\n  return Interaction;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/managers/interaction.js?");

/***/ }),

/***/ "./src/js/app/model/model.js":
/*!***********************************!*\
  !*** ./src/js/app/model/model.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Model; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _components_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/material */ \"./src/js/app/components/material.js\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/helpers */ \"./src/js/utils/helpers.js\");\n/* harmony import */ var _utils_bufferGeometryUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/bufferGeometryUtils */ \"./src/js/utils/bufferGeometryUtils.js\");\n/* harmony import */ var _loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../loaders/GLTFLoader */ \"./src/js/app/loaders/GLTFLoader.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n // Loads in a single object from the config file\n\nvar Model = /*#__PURE__*/function () {\n  function Model(scene, manager, textures) {\n    _classCallCheck(this, Model);\n\n    this.scene = scene;\n    this.textures = textures;\n    this.manager = manager;\n    this.obj = null;\n    this.ref = null;\n  }\n\n  _createClass(Model, [{\n    key: \"load\",\n    value: function load(type) {\n      var _this = this;\n\n      // Manager is passed in to loader to determine when loading done in main\n      switch (type) {\n        case 'gltf':\n          // Load model with selected loader\n          new _loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_4__[\"GLTFLoader\"](this.manager).load(_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].models[_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].model.selected].path, function (gltf) {\n            var scene = gltf.scene;\n            var mesh;\n\n            if (_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].shadow.enabled) {\n              scene.traverse(function (node) {\n                if (node.isMesh || node.isLight) node.castShadow = true;\n\n                if (node.isMesh) {\n                  node.material.wireframe = _data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].mesh.wireframe;\n                  mesh = node;\n                }\n              });\n            }\n\n            _this.obj = mesh;\n            _utils_bufferGeometryUtils__WEBPACK_IMPORTED_MODULE_3__[\"BufferGeometryUtils\"].computeTangents(mesh.geometry);\n            var group = new three__WEBPACK_IMPORTED_MODULE_0__[\"Group\"]();\n            group.scale.multiplyScalar(0.25);\n\n            _this.scene.add(group);\n\n            _this.ref = group; // To make sure that the matrixWorld is up to date for the boxhelpers\n\n            group.updateMatrixWorld(true);\n            group.add(mesh); // Add to scene\n\n            _this.scene.add(scene);\n          }, _utils_helpers__WEBPACK_IMPORTED_MODULE_2__[\"default\"].logProgress(), _utils_helpers__WEBPACK_IMPORTED_MODULE_2__[\"default\"].logError());\n          break;\n\n        case 'object':\n          // Load model with ObjectLoader\n          new three__WEBPACK_IMPORTED_MODULE_0__[\"ObjectLoader\"](this.manager).load(_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].models[_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].model.selected].path, function (obj) {\n            obj.traverse(function (child) {\n              if (child instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]) {\n                // Create material for mesh and set its map to texture by name from preloaded textures\n                var material = new _components_material__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0xffffff).standard;\n                material.map = _this.textures.UV;\n                child.material = material; // Set to cast and receive shadow if enabled\n\n                if (_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].shadow.enabled) {\n                  child.receiveShadow = true;\n                  child.castShadow = true;\n                }\n              }\n            }); // Set prop to obj so it can be accessed from outside the class\n\n            _this.obj = obj;\n            _this.ref = obj;\n            obj.scale.multiplyScalar(_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].models[_data_config__WEBPACK_IMPORTED_MODULE_5__[\"default\"].model.selected].scale);\n\n            _this.scene.add(obj);\n          }, _utils_helpers__WEBPACK_IMPORTED_MODULE_2__[\"default\"].logProgress(), _utils_helpers__WEBPACK_IMPORTED_MODULE_2__[\"default\"].logError());\n          break;\n      }\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      this.scene.remove(this.ref);\n    }\n  }]);\n\n  return Model;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/model/model.js?");

/***/ }),

/***/ "./src/js/app/model/texture.js":
/*!*************************************!*\
  !*** ./src/js/app/model/texture.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Texture; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\");\n/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(es6_promise__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/helpers */ \"./src/js/utils/helpers.js\");\n/* harmony import */ var _data_config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/config */ \"./src/js/data/config.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n // Promise polyfill for IE\n\n\n\n // This class preloads all textures in the imageFiles array in the Config via ES6 Promises.\n// Once all textures are done loading the model itself will be loaded after the Promise .then() callback.\n// Using promises to preload textures prevents issues when applying textures to materials\n// before the textures have loaded.\n\nvar Texture = /*#__PURE__*/function () {\n  function Texture() {\n    _classCallCheck(this, Texture);\n\n    // Prop that will contain all loaded textures\n    this.textures = {};\n  }\n\n  _createClass(Texture, [{\n    key: \"load\",\n    value: function load() {\n      var _this = this;\n\n      var loader = new three__WEBPACK_IMPORTED_MODULE_0__[\"TextureLoader\"]();\n      var maxAnisotropy = _data_config__WEBPACK_IMPORTED_MODULE_3__[\"default\"].maxAnisotropy;\n      var imageFiles = _data_config__WEBPACK_IMPORTED_MODULE_3__[\"default\"].texture.imageFiles;\n      var promiseArray = [];\n      loader.setPath(_data_config__WEBPACK_IMPORTED_MODULE_3__[\"default\"].texture.path);\n      imageFiles.forEach(function (imageFile) {\n        // Add an individual Promise for each image in array\n        promiseArray.push(new es6_promise__WEBPACK_IMPORTED_MODULE_1__[\"Promise\"](function (resolve, reject) {\n          // Each Promise will attempt to load the image file\n          loader.load(imageFile.image, // This gets called on load with the loaded texture\n          function (texture) {\n            texture.anisotropy = maxAnisotropy; // Resolve Promise with object of texture if it is instance of THREE.Texture\n\n            var modelOBJ = {};\n            modelOBJ[imageFile.name] = texture;\n            if (modelOBJ[imageFile.name] instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"]) resolve(modelOBJ);\n          }, _utils_helpers__WEBPACK_IMPORTED_MODULE_2__[\"default\"].logProgress(), function (xhr) {\n            return reject(new Error(xhr + 'An error occurred loading while loading ' + imageFile.image));\n          });\n        }));\n      }); // Iterate through all Promises in array and return another Promise when all have resolved or console log reason when any reject\n\n      return es6_promise__WEBPACK_IMPORTED_MODULE_1__[\"Promise\"].all(promiseArray).then(function (textures) {\n        // Set the textures prop object to have name be the resolved texture\n        for (var i = 0; i < textures.length; i++) {\n          _this.textures[Object.keys(textures[i])[0]] = textures[i][Object.keys(textures[i])[0]];\n        }\n      }, function (reason) {\n        return console.log(reason);\n      });\n    }\n  }]);\n\n  return Texture;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/app/model/texture.js?");

/***/ }),

/***/ "./src/js/data/config.js":
/*!*******************************!*\
  !*** ./src/js/data/config.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tweenjs/tween.js */ \"./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n // This object contains the state of the app\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  isDev: false,\n  isShowingStats: true,\n  isLoaded: false,\n  isTweening: false,\n  isRotating: true,\n  isMouseMoving: false,\n  isMouseOver: false,\n  maxAnisotropy: 1,\n  dpr: 1,\n  easing: _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Easing.Quadratic.InOut,\n  duration: 500,\n  model: {\n    selected: 0,\n    initialTypes: ['gltf', 'object'],\n    type: 'gltf'\n  },\n  models: [{\n    path: './assets/models/duck.gltf',\n    scale: 20,\n    type: 'gltf'\n  }, {\n    path: './assets/models/Teapot.json',\n    scale: 20,\n    type: 'object'\n  }],\n  texture: {\n    path: './assets/textures/',\n    imageFiles: [{\n      name: 'UV',\n      image: 'UV_Grid_Sm.jpg'\n    }]\n  },\n  mesh: {\n    enableHelper: true,\n    wireframe: false,\n    translucent: false,\n    material: {\n      color: 0xffffff,\n      emissive: 0xffffff\n    }\n  },\n  fog: {\n    color: 0xffffff,\n    near: 0.0008\n  },\n  camera: {\n    fov: 40,\n    near: 2,\n    far: 1000,\n    aspect: 1,\n    posX: 0,\n    posY: 30,\n    posZ: 40\n  },\n  controls: {\n    autoRotate: true,\n    autoRotateSpeed: -0.5,\n    rotateSpeed: 0.5,\n    zoomSpeed: 0.8,\n    minDistance: 200,\n    maxDistance: 600,\n    minPolarAngle: Math.PI / 5,\n    maxPolarAngle: Math.PI / 2,\n    minAzimuthAngle: -Infinity,\n    maxAzimuthAngle: Infinity,\n    enableDamping: true,\n    dampingFactor: 0.5,\n    enableZoom: true,\n    target: {\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  },\n  ambientLight: {\n    enabled: true,\n    color: 0x141414\n  },\n  directionalLight: {\n    enabled: true,\n    color: 0xf0f0f0,\n    intensity: 0.4,\n    x: -75,\n    y: 280,\n    z: 150\n  },\n  shadow: {\n    enabled: true,\n    helperEnabled: true,\n    bias: 0,\n    mapWidth: 2048,\n    mapHeight: 2048,\n    near: 250,\n    far: 400,\n    top: 100,\n    right: 100,\n    bottom: -100,\n    left: -100\n  },\n  pointLight: {\n    enabled: true,\n    color: 0xffffff,\n    intensity: 0.34,\n    distance: 115,\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  hemiLight: {\n    enabled: true,\n    color: 0xc8c8c8,\n    groundColor: 0xffffff,\n    intensity: 0.55,\n    x: 0,\n    y: 0,\n    z: 0\n  }\n});\n\n//# sourceURL=webpack:///./src/js/data/config.js?");

/***/ }),

/***/ "./src/js/utils/bufferGeometryUtils.js":
/*!*********************************************!*\
  !*** ./src/js/utils/bufferGeometryUtils.js ***!
  \*********************************************/
/*! exports provided: BufferGeometryUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BufferGeometryUtils\", function() { return BufferGeometryUtils; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar BufferGeometryUtils = {\n  computeTangents: function computeTangents(geometry) {\n    var index = geometry.index;\n    var attributes = geometry.attributes; // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n\n    var indices = index.array;\n    var positions = attributes.position.array;\n    var normals = attributes.normal.array;\n    var uvs = attributes.uv.array;\n    var nVertices = positions.length / 3;\n\n    if (attributes.tangent === undefined) {\n      geometry.setAttribute('tangent', new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"](new Float32Array(4 * nVertices), 4));\n    }\n\n    var tangents = attributes.tangent.array;\n    var tan1 = [],\n        tan2 = [];\n\n    for (var i = 0; i < nVertices; i++) {\n      tan1[i] = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n      tan2[i] = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n    }\n\n    var vA = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n        vB = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n        vC = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n        uvA = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\n        uvB = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\n        uvC = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](),\n        sdir = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n        tdir = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n\n    var groups = geometry.groups;\n\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i];\n      var start = group.start;\n      var count = group.count;\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n\n    var tmp = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n        tmp2 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n    var n = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n        n2 = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\n    var w, t, test;\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      t = tan1[v]; // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      test = tmp2.dot(tan2[v]);\n      w = test < 0.0 ? -1.0 : 1.0;\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i];\n      var start = group.start;\n      var count = group.count;\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  },\n\n  /**\n   * @param  {Array<BufferGeometry>} geometries\n   * @param  {Boolean} useGroups\n   * @return {BufferGeometry}\n   */\n  mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {\n    var isIndexed = geometries[0].index !== null;\n    var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    var attributes = {};\n    var morphAttributes = {};\n    var morphTargetsRelative = geometries[0].morphTargetsRelative;\n    var mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferGeometry\"]();\n    var offset = 0;\n\n    for (var i = 0; i < geometries.length; ++i) {\n      var geometry = geometries[i];\n      var attributesCount = 0; // ensure that all geometries are indexed, or none\n\n      if (isIndexed !== (geometry.index !== null)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n        return null;\n      } // gather attributes, exit early if they're different\n\n\n      for (var name in geometry.attributes) {\n        if (!attributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n          return null;\n        }\n\n        if (attributes[name] === undefined) attributes[name] = [];\n        attributes[name].push(geometry.attributes[name]);\n        attributesCount++;\n      } // ensure geometries have the same number of attributes\n\n\n      if (attributesCount !== attributesUsed.size) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n        return null;\n      } // gather morph attributes, exit early if they're different\n\n\n      if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n        return null;\n      }\n\n      for (var name in geometry.morphAttributes) {\n        if (!morphAttributesUsed.has(name)) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n          return null;\n        }\n\n        if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n        morphAttributes[name].push(geometry.morphAttributes[name]);\n      } // gather .userData\n\n\n      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n      mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n      if (useGroups) {\n        var count;\n\n        if (isIndexed) {\n          count = geometry.index.count;\n        } else if (geometry.attributes.position !== undefined) {\n          count = geometry.attributes.position.count;\n        } else {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n          return null;\n        }\n\n        mergedGeometry.addGroup(offset, count, i);\n        offset += count;\n      }\n    } // merge indices\n\n\n    if (isIndexed) {\n      var indexOffset = 0;\n      var mergedIndex = [];\n\n      for (var i = 0; i < geometries.length; ++i) {\n        var index = geometries[i].index;\n\n        for (var j = 0; j < index.count; ++j) {\n          mergedIndex.push(index.getX(j) + indexOffset);\n        }\n\n        indexOffset += geometries[i].attributes.position.count;\n      }\n\n      mergedGeometry.setIndex(mergedIndex);\n    } // merge attributes\n\n\n    for (var name in attributes) {\n      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n\n      if (!mergedAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n        return null;\n      }\n\n      mergedGeometry.setAttribute(name, mergedAttribute);\n    } // merge morph attributes\n\n\n    for (var name in morphAttributes) {\n      var numMorphTargets = morphAttributes[name][0].length;\n      if (numMorphTargets === 0) break;\n      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n      mergedGeometry.morphAttributes[name] = [];\n\n      for (var i = 0; i < numMorphTargets; ++i) {\n        var morphAttributesToMerge = [];\n\n        for (var j = 0; j < morphAttributes[name].length; ++j) {\n          morphAttributesToMerge.push(morphAttributes[name][j][i]);\n        }\n\n        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n\n        if (!mergedMorphAttribute) {\n          console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n          return null;\n        }\n\n        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n      }\n    }\n\n    return mergedGeometry;\n  },\n\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {BufferAttribute}\n   */\n  mergeBufferAttributes: function mergeBufferAttributes(attributes) {\n    var TypedArray;\n    var itemSize;\n    var normalized;\n    var arrayLength = 0;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      var attribute = attributes[i];\n\n      if (attribute.isInterleavedBufferAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n        return null;\n      }\n\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n        return null;\n      }\n\n      if (itemSize === undefined) itemSize = attribute.itemSize;\n\n      if (itemSize !== attribute.itemSize) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n        return null;\n      }\n\n      if (normalized === undefined) normalized = attribute.normalized;\n\n      if (normalized !== attribute.normalized) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n        return null;\n      }\n\n      arrayLength += attribute.array.length;\n    }\n\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n\n    for (var i = 0; i < attributes.length; ++i) {\n      array.set(attributes[i].array, offset);\n      offset += attributes[i].array.length;\n    }\n\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"](array, itemSize, normalized);\n  },\n\n  /**\n   * @param {Array<BufferAttribute>} attributes\n   * @return {Array<InterleavedBufferAttribute>}\n   */\n  interleaveAttributes: function interleaveAttributes(attributes) {\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    var TypedArray;\n    var arrayLength = 0;\n    var stride = 0; // calculate the the length and type of the interleavedBuffer\n\n    for (var i = 0, l = attributes.length; i < l; ++i) {\n      var attribute = attributes[i];\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n      if (TypedArray !== attribute.array.constructor) {\n        console.error('AttributeBuffers of different types cannot be interleaved');\n        return null;\n      }\n\n      arrayLength += attribute.array.length;\n      stride += attribute.itemSize;\n    } // Create the set of buffer attributes\n\n\n    var interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__[\"InterleavedBuffer\"](new TypedArray(arrayLength), stride);\n    var offset = 0;\n    var res = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW'];\n    var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n    for (var j = 0, l = attributes.length; j < l; j++) {\n      var attribute = attributes[j];\n      var itemSize = attribute.itemSize;\n      var count = attribute.count;\n      var iba = new three__WEBPACK_IMPORTED_MODULE_0__[\"InterleavedBufferAttribute\"](interleavedBuffer, itemSize, offset, attribute.normalized);\n      res.push(iba);\n      offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n      // at the appropriate offset\n\n      for (var c = 0; c < count; c++) {\n        for (var k = 0; k < itemSize; k++) {\n          iba[setters[k]](c, attribute[getters[k]](c));\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * @param {Array<BufferGeometry>} geometry\n   * @return {number}\n   */\n  estimateBytesUsed: function estimateBytesUsed(geometry) {\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    var mem = 0;\n\n    for (var name in geometry.attributes) {\n      var attr = geometry.getAttribute(name);\n      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n\n    var indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n  },\n\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {BufferGeometry>}\n   */\n  mergeVertices: function mergeVertices(geometry) {\n    var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute('position');\n    var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n    var nextIndex = 0; // attributes and new attribute arrays\n\n    var attributeNames = Object.keys(geometry.attributes);\n    var attrArrays = {};\n    var morphAttrsArrays = {};\n    var newIndices = [];\n    var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      attrArrays[name] = [];\n      var morphAttr = geometry.morphAttributes[name];\n\n      if (morphAttr) {\n        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(function () {\n          return [];\n        });\n      }\n    } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n    var decimalShift = Math.log10(1 / tolerance);\n    var shiftMultiplier = Math.pow(10, decimalShift);\n\n    for (var i = 0; i < vertexCount; i++) {\n      var index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\n\n      var hash = '';\n\n      for (var j = 0, l = attributeNames.length; j < l; j++) {\n        var name = attributeNames[j];\n        var attribute = geometry.getAttribute(name);\n        var itemSize = attribute.itemSize;\n\n        for (var k = 0; k < itemSize; k++) {\n          // double tilde truncates the decimal value\n          hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n        }\n      } // Add another reference to the vertex if it's already\n      // used by another index\n\n\n      if (hash in hashToIndex) {\n        newIndices.push(hashToIndex[hash]);\n      } else {\n        // copy data to the new index in the attribute arrays\n        for (var j = 0, l = attributeNames.length; j < l; j++) {\n          var name = attributeNames[j];\n          var attribute = geometry.getAttribute(name);\n          var morphAttr = geometry.morphAttributes[name];\n          var itemSize = attribute.itemSize;\n          var newarray = attrArrays[name];\n          var newMorphArrays = morphAttrsArrays[name];\n\n          for (var k = 0; k < itemSize; k++) {\n            var getterFunc = getters[k];\n            newarray.push(attribute[getterFunc](index));\n\n            if (morphAttr) {\n              for (var m = 0, ml = morphAttr.length; m < ml; m++) {\n                newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n              }\n            }\n          }\n        }\n\n        hashToIndex[hash] = nextIndex;\n        newIndices.push(nextIndex);\n        nextIndex++;\n      }\n    } // Generate typed arrays from new attribute arrays and update\n    // the attributeBuffers\n\n\n    var result = geometry.clone();\n\n    for (var i = 0, l = attributeNames.length; i < l; i++) {\n      var name = attributeNames[i];\n      var oldAttribute = geometry.getAttribute(name);\n      var buffer = new oldAttribute.array.constructor(attrArrays[name]);\n      var attribute = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"](buffer, oldAttribute.itemSize, oldAttribute.normalized);\n      result.setAttribute(name, attribute); // Update the attribute arrays\n\n      if (name in morphAttrsArrays) {\n        for (var j = 0; j < morphAttrsArrays[name].length; j++) {\n          var oldMorphAttribute = geometry.morphAttributes[name][j];\n          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n          var morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__[\"BufferAttribute\"](buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n          result.morphAttributes[name][j] = morphAttribute;\n        }\n      }\n    } // indices\n\n\n    result.setIndex(newIndices);\n    return result;\n  },\n\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {number} drawMode\n   * @return {BufferGeometry>}\n   */\n  toTrianglesDrawMode: function toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__[\"TrianglesDrawMode\"]) {\n      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n      return geometry;\n    }\n\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleFanDrawMode\"] || drawMode === three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleStripDrawMode\"]) {\n      var index = geometry.getIndex(); // generate index if not present\n\n      if (index === null) {\n        var indices = [];\n        var position = geometry.getAttribute('position');\n\n        if (position !== undefined) {\n          for (var i = 0; i < position.count; i++) {\n            indices.push(i);\n          }\n\n          geometry.setIndex(indices);\n          index = geometry.getIndex();\n        } else {\n          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n          return geometry;\n        }\n      } //\n\n\n      var numberOfTriangles = index.count - 2;\n      var newIndices = [];\n\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__[\"TriangleFanDrawMode\"]) {\n        // gl.TRIANGLE_FAN\n        for (var i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (var i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n\n      if (newIndices.length / 3 !== numberOfTriangles) {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n      } // build final geometry\n\n\n      var newGeometry = geometry.clone();\n      newGeometry.setIndex(newIndices);\n      newGeometry.clearGroups();\n      return newGeometry;\n    }\n\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n};\n\n\n//# sourceURL=webpack:///./src/js/utils/bufferGeometryUtils.js?");

/***/ }),

/***/ "./src/js/utils/detector.js":
/*!**********************************!*\
  !*** ./src/js/utils/detector.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mr.doob / http://mrdoob.com/\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  canvas: !!window.CanvasRenderingContext2D,\n  webgl: function () {\n    try {\n      var canvas = document.createElement('canvas');\n      return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      return false;\n    }\n  }(),\n  workers: !!window.Worker,\n  fileapi: window.File && window.FileReader && window.FileList && window.Blob,\n  getWebGLErrorMessage: function getWebGLErrorMessage() {\n    var element = document.createElement('div');\n    element.id = 'webgl-error-message';\n    element.style.fontFamily = 'monospace';\n    element.style.fontSize = '13px';\n    element.style.fontWeight = 'normal';\n    element.style.textAlign = 'center';\n    element.style.background = '#fff';\n    element.style.color = '#000';\n    element.style.padding = '1.5em';\n    element.style.width = '400px';\n    element.style.margin = '5em auto 0';\n\n    if (!this.webgl) {\n      element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000000\">WebGL</a>.<br />', 'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000000\">here</a>.'].join('\\n') : ['Your browser does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000000\">WebGL</a>.<br/>', 'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000000\">here</a>.'].join('\\n');\n    }\n\n    return element;\n  },\n  addGetWebGLMessage: function addGetWebGLMessage(parameters) {\n    var parent, id, element;\n    parameters = parameters || {};\n    parent = parameters.parent !== undefined ? parameters.parent : document.body;\n    id = parameters.id !== undefined ? parameters.id : 'oldie';\n    element = this.getWebGLErrorMessage();\n    element.id = id;\n    parent.appendChild(element);\n  }\n});\n\n//# sourceURL=webpack:///./src/js/utils/detector.js?");

/***/ }),

/***/ "./src/js/utils/helpers.js":
/*!*********************************!*\
  !*** ./src/js/utils/helpers.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Helpers; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Provides simple static functions that are used multiple times in the app\nvar Helpers = /*#__PURE__*/function () {\n  function Helpers() {\n    _classCallCheck(this, Helpers);\n  }\n\n  _createClass(Helpers, null, [{\n    key: \"throttle\",\n    value: function throttle(fn, threshhold, scope) {\n      threshhold || (threshhold = 250);\n      var last, deferTimer;\n      return function () {\n        var context = scope || this;\n        var now = +new Date(),\n            args = arguments;\n\n        if (last && now < last + threshhold) {\n          clearTimeout(deferTimer);\n          deferTimer = setTimeout(function () {\n            last = now;\n            fn.apply(context, args);\n          }, threshhold);\n        } else {\n          last = now;\n          fn.apply(context, args);\n        }\n      };\n    }\n  }, {\n    key: \"logProgress\",\n    value: function logProgress() {\n      return function (xhr) {\n        if (xhr.lengthComputable) {\n          var percentComplete = xhr.loaded / xhr.total * 100;\n          console.log(Math.round(percentComplete, 2) + '% downloaded');\n        }\n      };\n    }\n  }, {\n    key: \"logError\",\n    value: function logError() {\n      return function (xhr) {\n        console.error(xhr);\n      };\n    }\n  }, {\n    key: \"handleColorChange\",\n    value: function handleColorChange(color) {\n      return function (value) {\n        if (typeof value === 'string') {\n          value = value.replace('#', '0x');\n        }\n\n        color.setHex(value);\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(mesh) {\n      this.needsUpdate(mesh.material, mesh.geometry);\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate(material, geometry) {\n      return function () {\n        material.shading = +material.shading; //Ensure number\n\n        material.vertexColors = +material.vertexColors; //Ensure number\n\n        material.side = +material.side; //Ensure number\n\n        material.needsUpdate = true;\n        geometry.verticesNeedUpdate = true;\n        geometry.normalsNeedUpdate = true;\n        geometry.colorsNeedUpdate = true;\n      };\n    }\n  }, {\n    key: \"updateTexture\",\n    value: function updateTexture(material, materialKey, textures) {\n      return function (key) {\n        material[materialKey] = textures[key];\n        material.needsUpdate = true;\n      };\n    }\n  }]);\n\n  return Helpers;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/utils/helpers.js?");

/***/ }),

/***/ "./src/js/utils/keyboard.js":
/*!**********************************!*\
  !*** ./src/js/utils/keyboard.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Keyboard; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ALIAS = {\n  'left': 37,\n  'up': 38,\n  'right': 39,\n  'down': 40,\n  'space': 32,\n  'tab': 9,\n  'escape': 27\n};\n\nvar Keyboard = /*#__PURE__*/function () {\n  function Keyboard(domElement) {\n    var _this = this;\n\n    _classCallCheck(this, Keyboard);\n\n    this.domElement = domElement || document;\n    this.keyCodes = {}; // bind keyEvents\n\n    this.domElement.addEventListener('keydown', function (event) {\n      return _this.onKeyChange(event);\n    }, false);\n    this.domElement.addEventListener('keyup', function (event) {\n      return _this.onKeyChange(event);\n    }, false); // bind window blur\n\n    window.addEventListener('blur', function () {\n      return _this.onBlur;\n    }, false);\n  }\n\n  _createClass(Keyboard, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      this.domElement.removeEventListener('keydown', function (event) {\n        return _this2.onKeyChange(event);\n      }, false);\n      this.domElement.removeEventListener('keyup', function (event) {\n        return _this2.onKeyChange(event);\n      }, false); // unbind window blur event\n\n      window.removeEventListener('blur', function () {\n        return _this2.onBlur;\n      }, false);\n    }\n  }, {\n    key: \"onBlur\",\n    value: function onBlur() {\n      for (var prop in this.keyCodes) {\n        this.keyCodes[prop] = false;\n      }\n    }\n  }, {\n    key: \"onKeyChange\",\n    value: function onKeyChange(event) {\n      // log to debug\n      //console.log('onKeyChange', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n      // update this.keyCodes\n      var keyCode = event.keyCode;\n      this.keyCodes[keyCode] = event.type === 'keydown';\n    }\n  }, {\n    key: \"pressed\",\n    value: function pressed(keyDesc) {\n      var keys = keyDesc.split('+');\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var pressed = false;\n\n        if (Object.keys(ALIAS).indexOf(key) != -1) {\n          pressed = this.keyCodes[ALIAS[key]];\n        } else {\n          pressed = this.keyCodes[key.toUpperCase().charCodeAt(0)];\n        }\n\n        if (!pressed) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"eventMatches\",\n    value: function eventMatches(event, keyDesc) {\n      var aliases = ALIAS;\n      var aliasKeys = Object.keys(aliases);\n      var keys = keyDesc.split('+'); // log to debug\n      // console.log('eventMatches', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var pressed = false;\n\n        if (key === 'shift') {\n          pressed = event.shiftKey ? true : false;\n        } else if (key === 'ctrl') {\n          pressed = event.ctrlKey ? true : false;\n        } else if (key === 'alt') {\n          pressed = event.altKey ? true : false;\n        } else if (key === 'meta') {\n          pressed = event.metaKey ? true : false;\n        } else if (aliasKeys.indexOf(key) !== -1) {\n          pressed = event.keyCode === aliases[key];\n        } else if (event.keyCode === key.toUpperCase().charCodeAt(0)) {\n          pressed = true;\n        }\n\n        if (!pressed) return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return Keyboard;\n}();\n\n\n\n//# sourceURL=webpack:///./src/js/utils/keyboard.js?");

/***/ }),

/***/ "./src/js/utils/orbitControls.js":
/*!***************************************!*\
  !*** ./src/js/utils/orbitControls.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (THREE) {\n  var MOUSE = THREE.MOUSE;\n  if (!MOUSE) MOUSE = {\n    LEFT: 0,\n    MIDDLE: 1,\n    RIGHT: 2\n  };\n  /**\n   * @author qiao / https://github.com/qiao\n   * @author mrdoob / http://mrdoob.com\n   * @author alteredq / http://alteredqualia.com/\n   * @author WestLangley / http://github.com/WestLangley\n   * @author erich666 / http://erichaines.com\n   */\n\n  /*global THREE, console */\n\n  function OrbitConstraint(object) {\n    this.object = object; // \"target\" sets the location of focus, where the object orbits around\n    // and where it pans with respect to.\n\n    this.target = new THREE.Vector3(); // Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\n    this.minDistance = 0;\n    this.maxDistance = Infinity; // Limits to how far you can zoom in and out ( OrthographicCamera only )\n\n    this.minZoom = 0;\n    this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n\n    this.minPolarAngle = 0; // radians\n\n    this.maxPolarAngle = Math.PI; // radians\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\n    this.minAzimuthAngle = -Infinity; // radians\n\n    this.maxAzimuthAngle = Infinity; // radians\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n\n    this.enableDamping = false;\n    this.dampingFactor = 0.25; ////////////\n    // internals\n\n    var scope = this;\n    var EPS = 0.000001; // Current position in spherical coordinate system.\n\n    var theta;\n    var phi; // Pending changes\n\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var panOffset = new THREE.Vector3();\n    var zoomChanged = false; // API\n\n    this.getPolarAngle = function () {\n      return phi;\n    };\n\n    this.getAzimuthalAngle = function () {\n      return theta;\n    };\n\n    this.rotateLeft = function (angle) {\n      thetaDelta -= angle;\n    };\n\n    this.rotateUp = function (angle) {\n      phiDelta -= angle;\n    }; // pass in distance in world space to move left\n\n\n    this.panLeft = function () {\n      var v = new THREE.Vector3();\n      return function panLeft(distance) {\n        var te = this.object.matrix.elements; // get X column of matrix\n\n        v.set(te[0], te[1], te[2]);\n        v.multiplyScalar(-distance);\n        panOffset.add(v);\n      };\n    }(); // pass in distance in world space to move up\n\n\n    this.panUp = function () {\n      var v = new THREE.Vector3();\n      return function panUp(distance) {\n        var te = this.object.matrix.elements; // get Y column of matrix\n\n        v.set(te[4], te[5], te[6]);\n        v.multiplyScalar(distance);\n        panOffset.add(v);\n      };\n    }(); // pass in x,y of change desired in pixel space,\n    // right and down are positive\n\n\n    this.pan = function (deltaX, deltaY, screenWidth, screenHeight) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        // perspective\n        var position = scope.object.position;\n        var offset = position.clone().sub(scope.target);\n        var targetDistance = offset.length(); // half of the fov is center to top of screen\n\n        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we actually don't use screenWidth, since perspective camera is fixed to screen height\n\n        scope.panLeft(2 * deltaX * targetDistance / screenHeight);\n        scope.panUp(2 * deltaY * targetDistance / screenHeight);\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        // orthographic\n        scope.panLeft(deltaX * (scope.object.right - scope.object.left) / screenWidth);\n        scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / screenHeight);\n      } else {\n        // camera neither orthographic or perspective\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n      }\n    };\n\n    this.dollyIn = function (dollyScale) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        scale /= dollyScale;\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      }\n    };\n\n    this.dollyOut = function (dollyScale) {\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n        scale *= dollyScale;\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n      }\n    };\n\n    this.update = function () {\n      var offset = new THREE.Vector3(); // so camera.up is the orbit axis\n\n      var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n      var quatInverse = quat.clone().inverse();\n      var lastPosition = new THREE.Vector3();\n      var lastQuaternion = new THREE.Quaternion();\n      return function () {\n        var position = this.object.position;\n        offset.copy(position).sub(this.target); // rotate offset to \"y-axis-is-up\" space\n\n        offset.applyQuaternion(quat); // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z); // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n        theta += thetaDelta;\n        phi += phiDelta; // restrict theta to be between desired limits\n\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta)); // restrict phi to be between desired limits\n\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi)); // restrict phi to be betwee EPS and PI-EPS\n\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n        var radius = offset.length() * scale; // restrict radius to be between desired limits\n\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius)); // move target to panned location\n\n        this.target.add(panOffset);\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta); // rotate offset back to \"camera-up-vector-is-up\" space\n\n        offset.applyQuaternion(quatInverse);\n        position.copy(this.target).add(offset);\n        this.object.lookAt(this.target);\n\n        if (this.enableDamping === true) {\n          thetaDelta *= 1 - this.dampingFactor;\n          phiDelta *= 1 - this.dampingFactor;\n        } else {\n          thetaDelta = 0;\n          phiDelta = 0;\n        }\n\n        scale = 1;\n        panOffset.set(0, 0, 0); // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (zoomChanged || lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n          lastPosition.copy(this.object.position);\n          lastQuaternion.copy(this.object.quaternion);\n          zoomChanged = false;\n          return true;\n        }\n\n        return false;\n      };\n    }();\n  } // This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n  // the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n  // supported.\n  //\n  //    Orbit - left mouse / touch: one finger move\n  //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n  //    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\n  function OrbitControls(object, domElement) {\n    var constraint = new OrbitConstraint(object);\n    this.domElement = domElement !== undefined ? domElement : document; // API\n\n    Object.defineProperty(this, 'constraint', {\n      get: function get() {\n        return constraint;\n      }\n    });\n\n    this.getPolarAngle = function () {\n      return constraint.getPolarAngle();\n    };\n\n    this.getAzimuthalAngle = function () {\n      return constraint.getAzimuthalAngle();\n    }; // Set to false to disable this control\n\n\n    this.enabled = true; // center is old, deprecated; use \"target\" instead\n\n    this.center = this.target; // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility.\n    // Set to false to disable zooming\n\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0; // Set to false to disable rotating\n\n    this.enableRotate = true;\n    this.rotateSpeed = 1.0; // Set to false to disable panning\n\n    this.enablePan = true;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n    // Set to false to disable use of the keys\n\n    this.enableKeys = true; // The four arrow keys\n\n    this.keys = {\n      LEFT: 37,\n      UP: 38,\n      RIGHT: 39,\n      BOTTOM: 40\n    }; // Mouse buttons\n\n    this.mouseButtons = {\n      ORBIT: THREE.MOUSE.LEFT,\n      ZOOM: THREE.MOUSE.MIDDLE,\n      PAN: THREE.MOUSE.RIGHT\n    }; ////////////\n    // internals\n\n    var scope = this;\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n    var STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_DOLLY: 4,\n      TOUCH_PAN: 5\n    };\n    var state = STATE.NONE; // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom; // events\n\n    var changeEvent = {\n      type: 'change'\n    };\n    var startEvent = {\n      type: 'start'\n    };\n    var endEvent = {\n      type: 'end'\n    }; // pass in x,y of change desired in pixel space,\n    // right and down are positive\n\n    function pan(deltaX, deltaY) {\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n      constraint.pan(deltaX, deltaY, element.clientWidth, element.clientHeight);\n    }\n\n    this.update = function () {\n      if (this.autoRotate && state === STATE.NONE) {\n        constraint.rotateLeft(getAutoRotationAngle());\n      }\n\n      if (constraint.update() === true) {\n        this.dispatchEvent(changeEvent);\n      }\n    };\n\n    this.reset = function () {\n      state = STATE.NONE;\n      this.target.copy(this.target0);\n      this.object.position.copy(this.position0);\n      this.object.zoom = this.zoom0;\n      this.object.updateProjectionMatrix();\n      this.dispatchEvent(changeEvent);\n      this.update();\n    };\n\n    function getAutoRotationAngle() {\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n    }\n\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n\n    function onMouseDown(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n\n      if (event.button === scope.mouseButtons.ORBIT) {\n        if (scope.enableRotate === false) return;\n        state = STATE.ROTATE;\n        rotateStart.set(event.clientX, event.clientY);\n      } else if (event.button === scope.mouseButtons.ZOOM) {\n        if (scope.enableZoom === false) return;\n        state = STATE.DOLLY;\n        dollyStart.set(event.clientX, event.clientY);\n      } else if (event.button === scope.mouseButtons.PAN) {\n        if (scope.enablePan === false) return;\n        state = STATE.PAN;\n        panStart.set(event.clientX, event.clientY);\n      }\n\n      if (state !== STATE.NONE) {\n        document.addEventListener('mousemove', onMouseMove, false);\n        document.addEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(startEvent);\n      }\n    }\n\n    function onMouseMove(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      if (state === STATE.ROTATE) {\n        if (scope.enableRotate === false) return;\n        rotateEnd.set(event.clientX, event.clientY);\n        rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n        constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n        constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n        rotateStart.copy(rotateEnd);\n      } else if (state === STATE.DOLLY) {\n        if (scope.enableZoom === false) return;\n        dollyEnd.set(event.clientX, event.clientY);\n        dollyDelta.subVectors(dollyEnd, dollyStart);\n\n        if (dollyDelta.y > 0) {\n          constraint.dollyIn(getZoomScale());\n        } else if (dollyDelta.y < 0) {\n          constraint.dollyOut(getZoomScale());\n        }\n\n        dollyStart.copy(dollyEnd);\n      } else if (state === STATE.PAN) {\n        if (scope.enablePan === false) return;\n        panEnd.set(event.clientX, event.clientY);\n        panDelta.subVectors(panEnd, panStart);\n        pan(panDelta.x, panDelta.y);\n        panStart.copy(panEnd);\n      }\n\n      if (state !== STATE.NONE) scope.update();\n    }\n\n    function onMouseUp()\n    /* event */\n    {\n      if (scope.enabled === false) return;\n      document.removeEventListener('mousemove', onMouseMove, false);\n      document.removeEventListener('mouseup', onMouseUp, false);\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n\n    function onMouseWheel(event) {\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;\n      event.preventDefault();\n      event.stopPropagation();\n      var delta = 0;\n\n      if (event.wheelDelta !== undefined) {\n        // WebKit / Opera / Explorer 9\n        delta = event.wheelDelta;\n      } else if (event.detail !== undefined) {\n        // Firefox\n        delta = -event.detail;\n      }\n\n      if (delta > 0) {\n        constraint.dollyOut(getZoomScale());\n      } else if (delta < 0) {\n        constraint.dollyIn(getZoomScale());\n      }\n\n      scope.update();\n      scope.dispatchEvent(startEvent);\n      scope.dispatchEvent(endEvent);\n    }\n\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n      switch (event.keyCode) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          scope.update();\n          break;\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          scope.update();\n          break;\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          scope.update();\n          break;\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          scope.update();\n          break;\n      }\n    }\n\n    function touchstart(event) {\n      if (scope.enabled === false) return;\n\n      switch (event.touches.length) {\n        case 1:\n          // one-fingered touch: rotate\n          if (scope.enableRotate === false) return;\n          state = STATE.TOUCH_ROTATE;\n          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n          break;\n\n        case 2:\n          // two-fingered touch: dolly\n          if (scope.enableZoom === false) return;\n          state = STATE.TOUCH_DOLLY;\n          var dx = event.touches[0].pageX - event.touches[1].pageX;\n          var dy = event.touches[0].pageY - event.touches[1].pageY;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          dollyStart.set(0, distance);\n          break;\n\n        case 3:\n          // three-fingered touch: pan\n          if (scope.enablePan === false) return;\n          state = STATE.TOUCH_PAN;\n          panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) scope.dispatchEvent(startEvent);\n    }\n\n    function touchmove(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n      event.stopPropagation();\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      switch (event.touches.length) {\n        case 1:\n          // one-fingered touch: rotate\n          if (scope.enableRotate === false) return;\n          if (state !== STATE.TOUCH_ROTATE) return;\n          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          rotateDelta.subVectors(rotateEnd, rotateStart); // rotating across whole screen goes 360 degrees around\n\n          constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed); // rotating up and down along whole screen attempts to go 360, but limited to 180\n\n          constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n          rotateStart.copy(rotateEnd);\n          scope.update();\n          break;\n\n        case 2:\n          // two-fingered touch: dolly\n          if (scope.enableZoom === false) return;\n          if (state !== STATE.TOUCH_DOLLY) return;\n          var dx = event.touches[0].pageX - event.touches[1].pageX;\n          var dy = event.touches[0].pageY - event.touches[1].pageY;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          dollyEnd.set(0, distance);\n          dollyDelta.subVectors(dollyEnd, dollyStart);\n\n          if (dollyDelta.y > 0) {\n            constraint.dollyOut(getZoomScale());\n          } else if (dollyDelta.y < 0) {\n            constraint.dollyIn(getZoomScale());\n          }\n\n          dollyStart.copy(dollyEnd);\n          scope.update();\n          break;\n\n        case 3:\n          // three-fingered touch: pan\n          if (scope.enablePan === false) return;\n          if (state !== STATE.TOUCH_PAN) return;\n          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          panDelta.subVectors(panEnd, panStart);\n          pan(panDelta.x, panDelta.y);\n          panStart.copy(panEnd);\n          scope.update();\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n    }\n\n    function touchend()\n    /* event */\n    {\n      if (scope.enabled === false) return;\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n    }\n\n    function contextmenu(event) {\n      event.preventDefault();\n    }\n\n    this.dispose = function () {\n      this.domElement.removeEventListener('contextmenu', contextmenu, false);\n      this.domElement.removeEventListener('mousedown', onMouseDown, false);\n      this.domElement.removeEventListener('mousewheel', onMouseWheel, false);\n      this.domElement.removeEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n      this.domElement.removeEventListener('touchstart', touchstart, false);\n      this.domElement.removeEventListener('touchend', touchend, false);\n      this.domElement.removeEventListener('touchmove', touchmove, false);\n      document.removeEventListener('mousemove', onMouseMove, false);\n      document.removeEventListener('mouseup', onMouseUp, false);\n      window.removeEventListener('keydown', onKeyDown, false);\n    };\n\n    this.domElement.addEventListener('contextmenu', contextmenu, false);\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n    window.addEventListener('keydown', onKeyDown, false); // force an update at start\n\n    this.update();\n  }\n\n  OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\n  OrbitControls.prototype.constructor = OrbitControls;\n  Object.defineProperties(OrbitControls.prototype, {\n    object: {\n      get: function get() {\n        return this.constraint.object;\n      }\n    },\n    target: {\n      get: function get() {\n        return this.constraint.target;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: target is now immutable. Use target.set() instead.');\n        this.constraint.target.copy(value);\n      }\n    },\n    minDistance: {\n      get: function get() {\n        return this.constraint.minDistance;\n      },\n      set: function set(value) {\n        this.constraint.minDistance = value;\n      }\n    },\n    maxDistance: {\n      get: function get() {\n        return this.constraint.maxDistance;\n      },\n      set: function set(value) {\n        this.constraint.maxDistance = value;\n      }\n    },\n    minZoom: {\n      get: function get() {\n        return this.constraint.minZoom;\n      },\n      set: function set(value) {\n        this.constraint.minZoom = value;\n      }\n    },\n    maxZoom: {\n      get: function get() {\n        return this.constraint.maxZoom;\n      },\n      set: function set(value) {\n        this.constraint.maxZoom = value;\n      }\n    },\n    minPolarAngle: {\n      get: function get() {\n        return this.constraint.minPolarAngle;\n      },\n      set: function set(value) {\n        this.constraint.minPolarAngle = value;\n      }\n    },\n    maxPolarAngle: {\n      get: function get() {\n        return this.constraint.maxPolarAngle;\n      },\n      set: function set(value) {\n        this.constraint.maxPolarAngle = value;\n      }\n    },\n    minAzimuthAngle: {\n      get: function get() {\n        return this.constraint.minAzimuthAngle;\n      },\n      set: function set(value) {\n        this.constraint.minAzimuthAngle = value;\n      }\n    },\n    maxAzimuthAngle: {\n      get: function get() {\n        return this.constraint.maxAzimuthAngle;\n      },\n      set: function set(value) {\n        this.constraint.maxAzimuthAngle = value;\n      }\n    },\n    enableDamping: {\n      get: function get() {\n        return this.constraint.enableDamping;\n      },\n      set: function set(value) {\n        this.constraint.enableDamping = value;\n      }\n    },\n    dampingFactor: {\n      get: function get() {\n        return this.constraint.dampingFactor;\n      },\n      set: function set(value) {\n        this.constraint.dampingFactor = value;\n      }\n    },\n    // backward compatibility\n    noZoom: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n        return !this.enableZoom;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n        this.enableZoom = !value;\n      }\n    },\n    noRotate: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n        return !this.enableRotate;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n        this.enableRotate = !value;\n      }\n    },\n    noPan: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n        return !this.enablePan;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n        this.enablePan = !value;\n      }\n    },\n    noKeys: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n        return !this.enableKeys;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n        this.enableKeys = !value;\n      }\n    },\n    staticMoving: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n        return !this.constraint.enableDamping;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n        this.constraint.enableDamping = !value;\n      }\n    },\n    dynamicDampingFactor: {\n      get: function get() {\n        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n        return this.constraint.dampingFactor;\n      },\n      set: function set(value) {\n        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n        this.constraint.dampingFactor = value;\n      }\n    }\n  });\n  return OrbitControls;\n};\n\n//# sourceURL=webpack:///./src/js/utils/orbitControls.js?");

/***/ }),

/***/ 0:
/*!*****************************!*\
  !*** multi ./src/js/app.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/js/app.js */\"./src/js/app.js\");\n\n\n//# sourceURL=webpack:///multi_./src/js/app.js?");

/***/ })

},[[0,"runtime","vendors"]]]);